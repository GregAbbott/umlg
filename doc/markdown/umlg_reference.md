<!-- UMLG Reference Manual -->

##UMLG Collection Semantics

UML has 2 boolean properties that specifies the collection semantics of a property. They are,

* uniqueness
* ordering

These properties only make sense when the property has a upper multiplicity greater than 1. Together they specify whether
a property will be one of the following,

* **Set** (isUnique = true, isOrdered = false)
* **List** (isUnique = false, isOrdered = true)
* **OrderedSet** (isUnique = true, isOrdered = true)
* **Bag** (isUnique = false, isOrdered = false)

UMLG has 4 corresponding java interfaces to represent the 4 collections.

* `org.umlg.runtime.collection.UmlgSet`
* `org.umlg.runtime.collection.UmlgSequence`
* `org.umlg.runtime.collection.UmlgOrderedSet`
* `org.umlg.runtime.collection.UmlgBag`

To implement `UmlgSet` and `UmlgSequence` the standard java Set and List collection classes are used.

For `UmlgBag` google guava's [Multiset](http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Multiset.html) is used

For `UmlgOrderedSet` apache collections' [ListOrderedSet](https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/set/ListOrderedSet.html) is used.

This implies that for any property with a upper multiplicity greater than 1 the property will be one of the 4 given types.

###An example

![image of set semantics](images/uml/quickpreview/org/umlg/setsemantics/Package_setsemantics_SetSemanticsClassDiagram.PNG)

Illustrates {unique}

    @Test
    public void testSet() {
        Performance p = new Performance();
        Reservation r1 = new Reservation();
        Reservation r2 = new Reservation();
        p.addToReservation(r1);
        p.addToReservation(r2);
        UMLG.get().commit();
        Assert.assertTrue(p.getReservation() instanceof UmlgSet);
        Assert.assertTrue(p.getReservation() instanceof Set);
        Assert.assertEquals(2, p.getReservation().size());
    }

Illustrates {ordered}

    @Test
    public void testList() {
        Performance p = new Performance();
        Request r1 = new Request();
        Request r2 = new Request();
        p.addToRequest(r1);
        p.addToRequest(r2);
        UMLG.get().commit();
        Assert.assertTrue(p.getRequest() instanceof UmlgSequence);
        Assert.assertTrue(p.getRequest() instanceof List);
        Assert.assertEquals(2, p.getRequest().size());
    }

Illustrates {ordered, unique}

    @Test
    public void testOrderedSet() {
        Order o = new Order();
        LineItem l1 = new LineItem();
        LineItem l2 = new LineItem();
        o.addToLineItem(l1);
        o.addToLineItem(l2);
        UMLG.get().commit();
        Assert.assertTrue(o.getLineItem() instanceof UmlgOrderedSet);
        Assert.assertTrue(o.getLineItem() instanceof Set);
        Assert.assertTrue(o.getLineItem() instanceof List);
        Assert.assertEquals(2, o.getLineItem().size());
    }

Illustrates {}

    @Test
    public void testBag() {
        Product p = new Product();
        Complaint c1 = new Complaint();
        Complaint c2 = new Complaint();
        p.addToComplaint(c1);
        p.addToComplaint(c2);
        UMLG.get().commit();
        Assert.assertTrue(p.getComplaint() instanceof UmlgBag);
        Assert.assertTrue(p.getComplaint() instanceof Multiset);
        Assert.assertEquals(2, p.getComplaint().size());
    }

##UMLG Types

###UML Primitive Types

UMLG supports UML's basic primitive types. These are,

* **Boolean**, translates to java's `java.lang.Boolean`
* **Integer**, translates to java's `java.lang.Integer`
* **Real**, translates to java's `java.lang.Double`
* **String**, translates to java's `java.lang.String`
* **UnlimitedNatural**, translates to java's `java.lang.Integer` <em class="bg-danger">UnlimitedNatural is any integer >= 0</em>

UMLG supports UML's java primitive types. These are,

* **boolean**, translates to java's `java.lang.Boolean`
* **int**, translates to java's `java.lang.Integer`
* **long**, translates to java's `java.lang.Long`
* **float**, translates to java's `java.lang.Float`
* **double**, translates to java's `java.lang.Double`
* **char**, <em class="bg-danger">Not yet implemented</em>
* **short**, <em class="bg-danger">Not yet implemented</em>
* **byte**, <em class="bg-danger">Not yet implemented</em>

###UMLG Data Types

From the UML specification.

>A data type is a type whose instances are identified only by their value. A DataType may contain attributes to support the
 modeling of structured data types.

UMLG has its own library of data types. This is packaged in **umlg-datatypes.uml**. umlg-datatypes.uml is prepackaged with
the application generated by the [UMLG maven archetype](http://umlg.org/getting_started.html "UMLG maven archetype").
Otherwise copy umlg-datatypes.uml to the directory of your model and import the library into your model.

**umlg-datatypes.uml** contains the following data types,

* **Email**, translates to `java.lang.String`
* **DateTime**, translates to `org.joda.time.DateTime`
* **Date**, translates to `org.joda.time.LocalDate`
* **Time**, translates to `org.joda.time.LocalTime`
* **InternationalPhoneNumber**, <em class="bg-danger">Not yet implemented</em>
* **LocalPhoneNumber**, <em class="bg-danger">Not yet implemented</em>
* **Interval**, <em class="bg-danger">Not yet implemented</em>
* **Duration**, <em class="bg-danger">Not yet implemented</em>
* **CreditCardNumber**, <em class="bg-danger">Not yet implemented</em>
* **Video**, <em class="bg-danger">Not yet implemented</em>
* **Audio**, <em class="bg-danger">Not yet implemented</em>
* **Image**, <em class="bg-danger">Not yet implemented</em>

###UMLG Validation Stereotypes

UMLG uses stereotypes to validate the data types. For most simple validations this is faster and easier than using ocl
constraints to implement the validation logic.

**UML Primitive Type validation stereotypes**

![image of validation profile, uml](images/uml/validationprofile/Profile_Umlg_Validation_NewDiagram.PNG)

**UML Java Primitive Type validation stereotypes**

![image of validation profile, java](images/uml/validationprofile/Profile_Umlg_Validation_JavaPrimitiveTypeProfileDiagram.PNG)

The UMLG validation profile is packaged in **validation.profile.uml**.

validation.profile.uml is prepackaged with the application generated by the
[UMLG maven archetype](http://umlg.org/getting_started.html "UMLG maven archetype").
Otherwise copy [validation.profile.uml](https://github.com/pietermartin/umlg/blob/master/umlglib/validation.profile.uml)
to the directory of your model and imported the library into your model.

**validation.profile.uml** contains the following stereotypes,

* **MinLength**, validates that a String has a length greater than or equal to the value specified on the stereotype
* **MaxLength**, validates that a String has a length smaller than or equal to the value specified on the stereotype
* **RangeLength**, validates that a String has a length within the range specified on the stereotype
* **MinInteger**, validates that a Integer is *greater* or equal to the specified value.
* **MaxInteger**, validates that a Integer is *smaller* or equal to the specified value.
* **RangeInteger**, validates that a Integer is in the the range specified.
* **MinUnlimitedNatural**, validates that a UnlimitedNatural (Integer) is *greater* or equal to the specified value.
* **MaxUnlimitedNatural**, validates that a UnlimitedNatural (Integer) is *smaller* or equal to the specified value.
* **RangeUnlimitedNatural**, validates that a UnlimitedNatural (Integer) is in the the range specified.
* **MinReal**, validates that a Real (Double) is *greater* or equal to the specified value.
* **MaxReal**, validates that a Real (Double) is *smaller* or equal to the specified value.
* **RangeReal**, validates that a Real (Double) is in the the range specified.

<br />

* **MinLong**, validates that a Float is *greater* or equal to the specified value.
* **MaxLong**, validates that a Float is *smaller* or equal to the specified value.
* **RangeLong**, validates that a Float  is in the the range specified.
* **MinFloat**, validates that a Float is *greater* or equal to the specified value.
* **MaxFloat**, validates that a Float is *smaller* or equal to the specified value.
* **RangeFloat**, validates that a Float is in the the range specified.
* **MinDouble**, validates that a Double is *greater* or equal to the specified value.
* **MaxDouble**, validates that a Double is *smaller* or equal to the specified value.
* **RangeDouble**, validates that a Double is in the the range specified.

#### Apply a validation stereotype

To use the a UMLG validation stereotype you need to apply the stereotype to a property and specify the max, min or range values.

![image of validation stereotype](images/uml/stereotype/validationStereotype.png)


##Associations

From the UML specification.

>An association describes a set of tuples whose values refer to typed instances. An instance of an association is called a
link.A link is a tuple with one value for each end of the association, where each value is an instance of the type of the
end.
>
>An association specifies a semantic relationship that can occur between typed instances. It has at least two ends
represented by properties, each of which is connected to the type of the end. More than one end of the association may
have the same type.
>
>...
>
>An association may represent a composite aggregation (i.e., a whole/part relationship). Only binary associations can be
 aggregations. Composite aggregation is a strong form of aggregation that requires a part instance be included in at most
 one composite at a time. If a composite is deleted, all of its parts are normally deleted with it. Note that a part can (where
 allowed) be removed from a composite before the composite is deleted, and thus not be deleted as part of the composite.
 Compositions may be linked in a directed acyclic graph with transitive deletion characteristics; that is, deleting an
 element in one part of the graph will also result in the deletion of all elements of the subgraph below that element.
 Composition is represented by the isComposite attribute on the part end of the association being set to true.

##Multiplicity

##Inheritence

##Interfaces

##Enumeration

##Association Classes

##Constraints

##Qualifiers

##Validation Profile

##Subsetting

##Redefinitions
