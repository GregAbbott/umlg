<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="../../assets/ico/favicon.ico">

    <title>Sqlg</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- UMLG doc style -->
    <link href="stylesheets/umlg-doc.css" rel="stylesheet">

    <!-- Syntax Highlighter -->
    <link href="stylesheets/prettify.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body data-spy="scroll" data-target="#affix-nav">
<header class="navbar navbar-fixed-top navbar-inverse" role="banner">
    <div class="container">
        <div class="navbar-header">
            <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="sqlg.html" class="navbar-brand">Sqlg</a>
        </div>
        <nav class="collapse navbar-collapse" role="navigation">
            <ul class="nav navbar-nav pull-right">
                <li>
                    <a href="https://github.com/pietermartin/sqlg">Github</a>
                </li>
            </ul>
        </nav>
    </div>
</header>

<!-- Begin Body -->
<div class="container umlgcontainer">
    <div class="row">
        <div class="col-md-3" id="leftcol">
            <div class="bs-docs-sidebar hidden-print" role="complementary">
                <ul class="nav bs-docs-sidebar" id="sidebar">
                    <li class="active"><a href="#IntroductionID">Introduction</a><ul class="nav">
<li><a href="#TinkerPopsupportedfeaturesID">TinkerPop supported features</a></li></ul>
</li><li><a href="#GettingStartedID">Getting Started</a><ul class="nav">
<li><a href="#MavenID">Maven</a></li><li><a href="#GremlinConsoleID">Gremlin Console</a></li></ul>
</li><li><a href="#DatatypesID">Data types</a></li><li><a href="#ArchitectureID">Architecture</a><ul class="nav">
<li><a href="#VertextablesID">Vertex tables</a></li><li><a href="#EdgetablesID">Edge tables</a></li><li><a href="#TinkerPop-modernID">TinkerPop-modern</a><ul class="nav">
<li><a href="#ERDiagramID">ER Diagram</a></li><li><a href="#V_personID">V_person</a></li><li><a href="#V_softwareID">V_software</a></li><li><a href="#E_knowsID">E_knows</a></li><li><a href="#E_createdID">E_created</a></li></ul>
</li><li><a href="#NamespacingandSchemasID">Namespacing and Schemas</a><ul class="nav">
<li><a href="#SchemasID">Schemas</a></li></ul>
</li></ul>
</li><li><a href="#IndexesID">Indexes</a><ul class="nav">
<li><a href="#ExampleID">Example</a><ul class="nav">
<li><a href="#TabledefinitionID">Table definition</a></li></ul>
</li></ul>
</li><li><a href="#SchemacreationID">Schema creation</a></li><li><a href="#MultipleJvmID">Multiple Jvm</a><ul class="nav">
<li><a href="#ExamplePostgresqlID">Example Postgresql</a></li></ul>
</li><li><a href="#GremlinID">Gremlin</a><ul class="nav">
<li><a href="#ExampleID">Example</a></li><li><a href="#PredicatesID">Predicates </a><ul class="nav">
<li><a href="#CompareexampleID">Compare example</a></li><li><a href="#ContainsexampleID">Contains example</a></li><li><a href="#TextpredicateID">Text predicate </a></li><li><a href="#LocalDateTime,LocalDateandLocalTimequeriesID">LocalDateTime, LocalDate and LocalTime queries</a></li></ul>
</li><li><a href="#OrderID">Order</a></li><li><a href="#RepeatStepID">RepeatStep</a></li></ul>
</li><li><a href="#BatchmodeID">Batch mode</a><ul class="nav">
<li><a href="#ExamplePostgresqlID">Example Postgresql</a></li></ul>
</li><li><a href="#PerformanceIndicatorID">Performance Indicator</a><ul class="nav">
<li><a href="#Sometrivialexamples.ID">Some trivial examples.</a><ul class="nav">
<li><a href="#Create10000objects,eachwith2propertiesID">Create 10000 objects, each with 2 properties</a></li><li><a href="#Create10001Persons,eachwith2propertiesandonefriendID">Create 10001 Persons, each with 2 properties and one friend</a></li><li><a href="#Postgres,Create1000000PersonsandDogswithapetedge.BatchModeon.ID">Postgres, Create 1 000 000 Persons and Dogs with a pet edge. BatchMode on.</a></li><li><a href="#HSQLDB,Create1000000PersonsandDogswithapetedge.ID">HSQLDB, Create 1 000 000 Persons and Dogs with a pet edge.</a></li></ul>
</li></ul>
</li>
                </ul>
            </div>
        </div>
        <div class="col-md-9">

            <p class="pull-right visible-xs">
                <button type="button" class="btn btn-primary btn-xs" data-toggle="offcanvas">Toggle nav</button>
            </p>
            <!-- Sqlg -->

<h2 id="IntroductionID">Introduction</h2>

<p><strong>Sqlg</strong> is a implementation of <a href="https://github.com/tinkerpop/tinkerpop3">TinkerPop3</a> on a <a href="http://en.wikipedia.org/wiki/Relational_database_management_system">RDBMS</a>.
Currently <a href="http://hsqldb.org/">HSQLDB</a> and <a href="http://www.postgresql.org/">Postgresql</a> are supported.</p>

<p>Sqlg has a <a href="https://groups.google.com/forum/?hl=en#!forum/sqlg">Google Group</a>.</p>

<h3 id="TinkerPopsupportedfeaturesID">TinkerPop supported features</h3>

<p>Sqlg passes TinkerPop's <code class="language-java">StructureStandardSuite</code> and <code class="language-java">ProcessStandardSuite</code> test suites.</p>

<p>Graph Features <strong>not</strong> implemented.</p>

<ul>
<li>Computer</li>
<li>ThreadedTransactions</li>
<li>Variables</li>
</ul>

<p>Vertex Features <strong>not</strong> implemented.</p>

<ul>
<li>MultiProperties</li>
<li>MetaProperties</li>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>StringIds</li>
<li>UuidIds</li>
<li>CustomIds</li>
<li>AnyIds</li>
</ul>

<p>Edge Features <strong>not</strong> implemented.</p>

<ul>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>StringIds</li>
<li>UuidIds</li>
<li>CustomIds</li>
<li>AnyIds</li>
</ul>

<p>Vertex property features <strong>not</strong> implemented.</p>

<ul>
<li>AddProperty</li>
<li>RemoveProperty</li>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>StringIds</li>
<li>UuidIds</li>
<li>CustomIds</li>
<li>AnyIds</li>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<p>Edge property feature <strong>not</strong> implemented.</p>

<ul>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<h2 id="GettingStartedID">Getting Started</h2>

<p><br /></p>

<h3 id="MavenID">Maven</h3>

<p><br /></p>

<p>Maven coordinates,</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-hsqldb&lt;/artifactId&gt;
    &lt;version&gt;1.1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-postgres&lt;/artifactId&gt;
    &lt;version&gt;1.1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Sqlg is designed to run as a singleton that can be shared among multiple threads. You can instantiate Sqlg using the standard
tinkerpop3 static constructors.</p>

<ul>
<li><code class="language-java">SqlgGraph.open(final Configuration configuration)</code></li>
<li><code class="language-java">SqlgGraph.open(final String pathToSqlgProperties)</code></li>
</ul>

<p>The configuration object requires the following properties.</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:hsqldb:file:/tmp/sqlg
jdbc.username=SA
jdbc.password=
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******
</code></pre>

<p>In the case of Postgres the database must already exist.</p>

<p>If you want to run the TinkerPop tests on Postgres you need to create upfront the various databases that are used.
These are,</p>

<ul>
<li>g1</li>
<li>g2</li>
<li>readGraph</li>
<li>standard</li>
<li>subgraph</li>
<li>temp</li>
<li>temp1</li>
<li>temp2</li>
<li>prototype</li>
</ul>

<p><br /></p>

<h3 id="GremlinConsoleID">Gremlin Console</h3>

<p><br /></p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">[pieter@pieter-laptop bin]$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.server
plugin activated: tinkerpop.utilities
plugin activated: tinkerpop.tinkergraph
gremlin&gt; :install org.umlg sqlg-hsqldb 1.1.0-SNAPSHOT
log4j:WARN No appenders could be found for logger (org.apache.tinkerpop.gremlin.groovy.util.DependencyGrabber).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
==&gt;Loaded: [org.umlg, sqlg-hsqldb, 1.1.0-SNAPSHOT]
gremlin&gt; :plugin list
==&gt;tinkerpop.server[active]
==&gt;tinkerpop.gephi
==&gt;tinkerpop.utilities[active]
==&gt;tinkerpop.sugar
==&gt;tinkerpop.credentials
==&gt;tinkerpop.tinkergraph[active]
==&gt;sqlg.hsqldb
gremlin&gt; :plugin use sqlg.hsqldb
==&gt;sqlg.hsqldb activated
gremlin&gt; graph = SqlgGraph.open('pathTo/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g = graph.traversal()
==&gt;graphtraversalsource[sqlggraph[SqlGraph], standard]
gremlin&gt; graph.io(graphml()).readGraph('../data/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;808
gremlin&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.server
plugin activated: tinkerpop.utilities
plugin activated: tinkerpop.tinkergraph
gremlin&gt; :install org.umlg sqlg-postgres 1.1.0-SNAPSHOT
log4j:WARN No appenders could be found for logger (org.apache.tinkerpop.gremlin.groovy.util.DependencyGrabber).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
==&gt;Loaded: [org.umlg, sqlg-postgres, 1.1.0-SNAPSHOT]
gremlin&gt; :plugin list
==&gt;tinkerpop.server[active]
==&gt;tinkerpop.gephi
==&gt;tinkerpop.utilities[active]
==&gt;tinkerpop.sugar
==&gt;tinkerpop.credentials
==&gt;tinkerpop.tinkergraph[active]
==&gt;sqlg.postgres
gremlin&gt; :plugin use sqlg.postgres
==&gt;sqlg.postgres activated
gremlin&gt; graph = SqlgGraph.open('pathTo/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g = graph.traversal()
==&gt;graphtraversalsource[sqlggraph[SqlGraph], standard]
gremlin&gt; graph.io(graphml()).readGraph('../data/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;808
gremlin&gt;
</code></pre>

<p><br /></p>

<h2 id="DatatypesID">Data types</h2>

<p><br /></p>

<div>
<table class="table table-striped table-bordered">
    <thead>
        <tr>
            <th>Java</th>
            <th>HSQLDB</th>
            <th>Postgres</th>
        </tr>
    </thead>
    <tbody>
        </tr>
            <td>Boolean</td>
            <td>BOOLEAN</td>
            <td>BOOLEAN</td>
        </tr>
        <tr>
            <td>Byte</td>
            <td>TINYINT</td>
            <td><strong>Not supported</strong></td>
        </tr>
        <tr>
            <td>Short</td>
            <td>SMALLINT</td>
            <td>SMALLINT</td>
        </tr>
        <tr>
            <td>Integer</td>
            <td>INTEGER</td>
            <td>INTEGER</td>
        </tr>
        <tr>
            <td>Long</td>
            <td>BIGINT</td>
            <td>BIGINT</td>
        </tr>
        <tr>
            <td>Float</td>
            <td><strong>Not supported</strong></td>
            <td>REAL</td>
        </tr>
        <tr>
            <td>Double</td>
            <td>DOUBLE</td>
            <td>DOUBLE PRECISION</td>
        </tr>
        <tr>
            <td>String</td>
            <td>LONGVARCHAR</td>
            <td>TEXT</td>
        </tr>
        <!-- Arrays -->
        <tr>
            <td>Boolean[]</td>
            <td>BOOLEAN ARRAY DEFAULT ARRAY[]</td>
            <td>BOOLEAN[]</td>
        </tr>
        <tr>
            <td>Byte[]</td>
            <td>LONGVARBINARY</td>
            <td>BYTEA</td>
        </tr>
        <tr>
            <td>Short[]</td>
            <td>SMALLINT ARRAY DEFAULT ARRAY[]</td>
            <td>SMALLINT[]</td>
        </tr>
        <tr>
            <td>Integer[]</td>
            <td>INTEGER ARRAY DEFAULT ARRAY[]</td>
            <td>INTEGER[]</td>
        </tr>
        <tr>
            <td>Long[]</td>
            <td>BIGINT ARRAY DEFAULT ARRAY[]</td>
            <td>BIGINT[]</td>
        </tr>
        <tr>
            <td>Float[]</td>
            <td>Not supported</td>
            <td>REAL[]</td>
        </tr>
        <tr>
            <td>Double[]</td>
            <td>DOUBLE ARRAY DEFAULT ARRAY[]</td>
            <td>DOUBLE PRECISION[]</td>
        </tr>
        <tr>
            <td>String[]</td>
            <td>LONGVARCHAR ARRAY DEFAULT ARRAY[]</td>
            <td>TEXT[]</td>
        </tr>
        <tr>
            <td>java.time.LocalDateTime</td>
            <td>TIMESTAMP WITH TIME ZONE</td>
            <td>TIMESTAMP WITH TIME ZONE</td>
        </tr>
        <tr>
            <td>java.time.LocalDate</td>
            <td>DATE</td>
            <td>DATE</td>
        </tr>
        <tr>
            <td>java.time.LocalTime</td>
            <td>TIME WITH TIME ZONE</td>
            <td>TIME WITH TIME ZONE</td>
        </tr>
        <tr>
            <td>com.fasterxml.jackson.databind.JsonNode</td>
            <td><strong>Not supported</strong></td>
            <td>JSONB</td>
        </tr>
    </tbody>
</table>
</div>

<p><strong>Note:</strong> <code class="language-java">java.time.LocalTime</code> drops the nano second precision.</p>

<p><br /></p>

<h2 id="ArchitectureID">Architecture</h2>

<p><br /></p>

<p>With the coming of vertex labels to TinkerPop3 the mapping of TinkerPop's graph semantics to that of a RDBMS became natural and useful.</p>

<h3 id="VertextablesID">Vertex tables</h3>

<p>Every unique vertex label maps to a table. Vertex tables are prefixed with a <code class="language-java">V_</code>. i.e. <code class="language-java">V_Person</code>. The vertex table
stores the vertex's properties.</p>

<h3 id="EdgetablesID">Edge tables</h3>

<p>Every unique edge label maps to a table. Edge tables are prefixed with a <code class="language-java">E_</code>. i.e. <code class="language-java">E_friend</code>. The edge table stores
each edge's adjacent vertex ids and the edge properties. The column corresponding to each adjacent vertex id (<code class="language-java">IN</code> and <code class="language-java">OUT</code>)
has a foreign key to the adjacent vertex's table.</p>

<p>From a rdbms' perspective each edge table is a classic <code class="language-java">many to many</code> join table between vertices.</p>

<h3 id="TinkerPop-modernID">TinkerPop-modern</h3>

<p>Taken from <a href="http://tinkerpop.incubator.apache.org/docs/3.0.0-SNAPSHOT/#intro">TinkerPop3</a></p>

<p><img src="images/sqlg/tinkerpop-modern-graph.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="ERDiagramID">ER Diagram</h4>

<p><img src="images/sqlg/tinkerpop-modern-er.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="V_personID">V_person</h4>

<p><img src="images/sqlg/V_person.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="V_softwareID">V_software</h4>

<p><img src="images/sqlg/V_software.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="E_knowsID">E_knows</h4>

<p><img src="images/sqlg/E_knows.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="E_createdID">E_created</h4>

<p><img src="images/sqlg/E_created.png" alt="image of tinkerpop-classic" title="" /></p>

<h3 id="NamespacingandSchemasID">Namespacing and Schemas</h3>

<p>Many RDBMS databases have the notion of a <code class="language-java">schema</code> as a namespace for tables. Sqlg supports schemas
for vertex labels. Distinct schemas for edge tables are unnecessary as edge tables are created in the schema of the adjacent <code class="language-java">out</code> vertex.
By default schemas for vertex tables go into the underlying databases' default schema. For postgresql and hsqldb this
is the <code class="language-java">public</code> schema.</p>

<p>To specify the schema for a label Sqlg uses the dot <code class="language-java">.</code> notation.</p>

<pre class="prettyprint"><code class="language-java">Vertex john = this.sqlgGraph.addVertex(T.label, "manager", "name", "john");
Vertex palace1 = this.sqlgGraph.addVertex(T.label, "continent.house", "name", "palace1");
Vertex corrola = this.sqlgGraph.addVertex(T.label, "fleet.car", "model", "corrola");
palace1.addEdge("managedBy", john);
corrola.addEdge("owner", john);
</code></pre>

<p>This will create a table <code class="language-java">V_manager</code> in the <code class="language-java">public</code> (default) schema. Table <code class="language-java">V_house</code> is in a <code class="language-java">continent</code> schema and table <code class="language-java">V_car</code>
is in a <code class="language-java">fleet</code> schema. For the edges a <code class="language-java">E_managedBy</code> table is created in the <code class="language-java">continent</code> schema and a <code class="language-java">E_owner</code> table in the <code class="language-java">fleet</code> schema.</p>

<p><br /></p>

<h4 id="SchemasID">Schemas</h4>

<p><br />
<img src="images/sqlg/schemas.png" alt="image of tinkerpop-classic" title="" />
<img src="images/sqlg/continent.png" alt="image of tinkerpop-classic" title="" />
<img src="images/sqlg/fleet.png" alt="image of tinkerpop-classic" title="" />
<img src="images/sqlg/public.png" alt="image of tinkerpop-classic" title="" /></p>

<p><br /></p>

<h2 id="IndexesID">Indexes</h2>

<p><br /></p>

<p>Sqlg supports basic indexing.</p>

<p><code class="language-java">org.umlg.sqlg.structure.SqlgGraph</code> has two methods on it to create indexes one for vertices and one for edges.</p>

<ul>
<li><code class="language-java">SqlgGraph.createVertexLabeledIndex(String label, Object... dummykeyValues)</code></li>
<li><code class="language-java">SqlgGraph.createEdgeLabeledIndex(String label, Object... dummykeyValues)</code></li>
</ul>

<p>The <code class="language-java">dummykeyValues</code> are required to indicate to Sqlg the name and type of the property. The type is needed when
the column does not yet exist and Sqlg needs to create it.</p>

<p>Outside of creating the index Sqlg has no further direct interaction with index logic. However gremlin queries with a
<code class="language-java">has</code> step will translate to a sql <code class="language-java">where</code> clause. If an index has been created on the property of the <code class="language-java">has</code> step then
the underlying sql engine will utilize that index.</p>

<p>The index does not need to be created upfront. It can be added any time.</p>

<h3 id="ExampleID">Example</h3>

<pre class="prettyprint"><code class="language-java">@Test
public void testIndexOnVertex() throws SQLException {
    this.sqlgGraph.createVertexLabeledIndex("Person", "name", "dummy");
    this.sqlgGraph.tx().commit();
    for (int i = 0; i &lt; 5000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "john" + i);
    }
    this.sqlgGraph.tx().commit();
    assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, "Person").has("name", "john50").count().next(), 0);

    //Check if the index is being used
    Connection conn = this.sqlgGraph.tx().getConnection();
    Statement statement = conn.createStatement();
    ResultSet rs = statement.executeQuery("explain analyze SELECT * FROM \"public\".\"V_Person\" a WHERE a.\"name\" = 'john50'");
    assertTrue(rs.next());
    String result = rs.getString(1);
    System.out.println(result);
    assertTrue(result.contains("Index Scan") || result.contains("Bitmap Heap Scan"));
    statement.close();
    this.sqlgGraph.tx().rollback();
}

Output: "Bitmap Heap Scan on "V_Person" a  (cost=4.42..32.42 rows=18 width=40) (actual time=0.016..0.016 rows=1 loops=1)"
</code></pre>

<p><br /></p>

<h4 id="TabledefinitionID">Table definition</h4>

<p><br />
<img src="images/sqlg/tableDefinition.png" alt="image of tinkerpop-classic" title="" /></p>

<p>In the above example, Sqlg created a table <code class="language-java">V_Person</code> with column <code class="language-java">name</code> and an index on the <code class="language-java">name</code> column.
Currently Sqlg only supports the default index. For postgresql this is a <code class="language-java">Btree</code> index.</p>

<p>The output shows the result of a postgres query explain plan. The result shows that postgres does indeed utilize the index.</p>

<p>The gremlin query <code class="language-java">this.sqlgGraph.traversal().V().has(T.label, "Person").has("name1", "john50")</code> will utilize the index on the <code class="language-java">name</code> field.</p>

<p><br /></p>

<h2 id="SchemacreationID">Schema creation</h2>

<p><br /></p>

<p>Sqlg creates the schema lazily. This is great, but comes with serious caveats.</p>

<p><strong>HSQLDB</strong> does not support transactional schema creation. HSQLDB automatically commits any schema creation/alter command
and immediately starts a new transaction.
This can have some rather unfortunate consequences, as HSQLDB will silently commit a user transaction thus invalidating
the user's transaction boundaries and semantics.</p>

<p><strong>Postgres</strong> supports transactional schema creation/alter commands. The user's transaction semantics remain intact.
 However schema creation commands creates table level locks which increases the risk of deadlocks in a multi-threaded environment. 
 Sqlg manages a global lock for schema creation to prevent postgres from dead locking.
 If multiple jvm(s) are used then a Hazelcast distributed lock is used.</p>

<p><br /></p>

<h2 id="MultipleJvmID">Multiple Jvm</h2>

<p><br /></p>

<p>It is possible to run many Sqlg instances pointing to the same underlying database. These instances can be in the same jvm
but is primarily intended for separate jvm(s) pointing to the same underlying database.</p>

<p>Sqlg caches database schema information. When multiple Sqlg instances point to the same database,
Sqlg uses <a href="http://hazelcast.com/">Hazelcast</a> as a distributed cache of the schema information.</p>

<p>To indicate to Sqlg that a <code class="language-java">Hazelcast</code> cluster is required  you must specify <code class="language-java">hazelcast.members=ipaddres1,ipaddres2,ipaddres3</code>
in the constructors configuration object. Hazelcast will then automatically set up the distributed cluster for the schema
information.</p>

<p><br /></p>

<h4 id="ExamplePostgresqlID">Example Postgresql</h4>

<p><br /></p>

<p><strong>Jvm 1</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******
hazelcast.members=127.0.0.1,127.0.0.2
</code></pre>

<p><strong>Jvm 2</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******
hazelcast.members=127.0.0.1,127.0.0.2
</code></pre>

<p><br /></p>

<h2 id="GremlinID">Gremlin</h2>

<p><br /></p>

<p>Sqlg has full support for gremlin and passes the TinkerPop test suite. 
However gremlin's fine grained graphy nature result in very high latency. </p>

<p>Sqlg optimizes gremlin by analyzing the steps and where possible combining them into a SqlgGraphStepCompiled or SqlgVertexStepCompiled.</p>

<p>Consecutive GraphStep, VertexStep, EdgeVertexStep, EdgeOtherVertexStep, HasStep, RepeatStep and OrderGlobalStep are currently combined.
The combined step will then in turn generate the sql statements to retrieve the data. It attempts to retrieve the data in as few distinct sql statements as possible.</p>

<p><strong>Note:</strong> Turn sql logging on by setting <code class="language-java">log4j.logger.org.umlg.sqlg=debug</code></p>

<p><br /></p>

<h4 id="ExampleID">Example</h4>

<p><br /></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showHighLatency() {
    Vertex easternUnion = this.sqlgGraph.addVertex(T.label, "Organization", "name", "EasternUnion");
    Vertex legal = this.sqlgGraph.addVertex(T.label, "Division", "name", "Legal");
    Vertex dispatch = this.sqlgGraph.addVertex(T.label, "Division", "name", "Dispatch");
    Vertex newYork = this.sqlgGraph.addVertex(T.label, "Office", "name", "NewYork");
    Vertex singapore = this.sqlgGraph.addVertex(T.label, "Office", "name", "Singapore");
    easternUnion.addEdge("organization_division", legal);
    easternUnion.addEdge("organization_division", dispatch);
    legal.addEdge("division_office", newYork);
    dispatch.addEdge("division_office", singapore);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
        .hasLabel("Organization")
        .out()
        .out();
    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; offices = traversal.toList();
    assertEquals(2, offices.size());
}

Before optimization:
[GraphStep([],vertex), HasStep([~label.eq(Organization)]), VertexStep(OUT,vertex), VertexStep(OUT,vertex)]
After optimization:
[SqlgGraphStepCompiled([],vertex)]
</code></pre>

<p>Without optimization the query <code class="language-java">this.sqlgGraph.traversal().V().hasLabel("Organization").out().out()</code> will result
in a number of database hits. First to get the organizations, then for each organization the divisions and then for each division the offices.
For an embedded db like HSQLDB this is still ok but for a database server like postgresql the performance impact is significant.</p>

<p>In the above example the GraphStep, HasStep and 2 VertexSteps are all combined into one step, SqlgGraphStepCompiled.</p>

<p>The before optimization output shows the steps that would have executed with if no optimization is performed. 
As the query only contains sequential optimizable steps they are all combined into one step. </p>

<p>The above example will retrieve the data in one sql query.</p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Office"."ID" AS "alias1",
    "public"."V_Office"."name" AS "alias2"
FROM
    "public"."V_Organization" INNER JOIN
    "public"."E_organization_division" ON "public"."V_Organization"."ID" = "public"."E_organization_division"."public.Organization__O" INNER JOIN
    "public"."V_Division" ON "public"."E_organization_division"."public.Division__I" = "public"."V_Division"."ID" INNER JOIN
    "public"."E_division_office" ON "public"."V_Division"."ID" = "public"."E_division_office"."public.Division__O" INNER JOIN
    "public"."V_Office" ON "public"."E_division_office"."public.Office__I" = "public"."V_Office"."ID"
</code></pre>

<p><br /></p>

<h3>Predicates</h3>

<p><br /></p>

<p>TinkerPop's <a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Compare.html">Compare</a> and 
<a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Contains.html">Contains</a> predicates are optimized 
to execute on the database.</p>

<p><br /></p>

<h4 id="CompareexampleID">Compare example</h4>

<p><br /></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showComparePredicate() {
    Vertex easternUnion = this.sqlgGraph.addVertex(T.label, "Organization", "name", "EasternUnion");
    Vertex legal = this.sqlgGraph.addVertex(T.label, "Division", "name", "Legal");
    Vertex dispatch = this.sqlgGraph.addVertex(T.label, "Division", "name", "Dispatch");
    Vertex newYork = this.sqlgGraph.addVertex(T.label, "Office", "name", "NewYork");
    Vertex singapore = this.sqlgGraph.addVertex(T.label, "Office", "name", "Singapore");
    easternUnion.addEdge("organization_division", legal);
    easternUnion.addEdge("organization_division", dispatch);
    legal.addEdge("division_office", newYork);
    dispatch.addEdge("division_office", singapore);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
        .hasLabel("Organization")
        .out()
        .out()
        .has("name", P.eq("Singapore"));
    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; offices = traversal.toList();
    assertEquals(1, offices.size());
    assertEquals(singapore, offices.get(0));
}
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Office"."ID" AS "alias1",
    "public"."V_Office"."name" AS "alias2"
FROM
    "public"."V_Organization" INNER JOIN
    "public"."E_organization_division" ON "public"."V_Organization"."ID" = "public"."E_organization_division"."public.Organization__O" INNER JOIN
    "public"."V_Division" ON "public"."E_organization_division"."public.Division__I" = "public"."V_Division"."ID" INNER JOIN
    "public"."E_division_office" ON "public"."V_Division"."ID" = "public"."E_division_office"."public.Division__O" INNER JOIN
    "public"."V_Office" ON "public"."E_division_office"."public.Office__I" = "public"."V_Office"."ID"
WHERE
    ( "public"."V_Office"."name" = ?)
</code></pre>

<p>The same pattern is used for all the  <a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Compare.html">Compare</a> predicates.     </p>

<p><br /></p>

<h4 id="ContainsexampleID">Contains example</h4>

<p><br /></p>

<p>Sqlg's implementation of <a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Contains.html">Contains</a> is slightly more complex.
For HSQLDB a regular <code class="language-java">in</code> clause is used.</p>

<p>For postgresql, instead of using a sql <code class="language-java">in</code> clause, i.e. <code class="language-java">where property in (?, ?...)</code> the values are bulk inserted into a temporary table and then a join to the temporary table is used
to constrain the results.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void showContainsPredicate() {
    List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(10000);
    for (int i = 0; i &lt; 10000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "number", i);
        numbers.add(i);
    }
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("number", P.within(numbers))
            .toList();

    assertEquals(10000, persons.size());
}
</code></pre>

<p>And the resulting sql on postgresql,    </p>

<pre class="prettyprint"><code class="language-java">CREATE TEMPORARY TABLE "V_BULK_TEMP_EDGEzf++PItI"("ID" SERIAL PRIMARY KEY, "within" INTEGER) ON COMMIT DROP;
COPY "V_BULK_TEMP_EDGEzf++PItI" ("within") FROM stdin DELIMITER '   ';
SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."number" AS "alias2"
FROM
    "public"."V_Person"
INNER JOIN  "V_BULK_TEMP_EDGEzf++PItI" tmp1 on"public"."V_Person"."number" = tmp1.within
</code></pre>

<p>This pattern makes <code class="language-java">P.within</code> and <code class="language-java">p.without</code> very fast even with millions of values being passed into the query. 
Benchmarking shows that doing a join on a temporary table is always faster than using the <code class="language-java">in</code> clause. 
For the case of there being only one value Sqlg will use an <code class="language-java">equals</code> instead of a temporay table or an <code class="language-java">in</code> statement.</p>

<p><br /></p>

<h4>Text predicate</h4>

<p><br /></p>

<p>Sqlg includes its own Text predicate for full text queries.</p>

<ul>
<li>Text.contains (case sensitive string contains)</li>
<li>Text.ncontains (case sensitive string does not contain)</li>
<li>Text.containsCIS (case insensitive string contains)</li>
<li>Text.ncontainsCIS (case insensitive string does not contain)</li>
<li>Text.startsWith (case sensitive string starts with)</li>
<li>Text.nstartsWith (case sensitive string does not start with)</li>
<li>Text.endsWith (case sensitive string ends with)</li>
<li>Text.nendsWith (case sensitive string does not end with)</li>
</ul>

<p><br /></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showTextPredicate() {
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John XXX Doe");
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peter YYY Snow");
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("name", Text.contains("XXX")).toList();

    assertEquals(1, persons.size());
    assertEquals(john, persons.get(0));
}
</code></pre>

<p>And the resulting sql on postgresql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."name" AS "alias2"
FROM
    "public"."V_Person"
WHERE
    ( "public"."V_Person"."name" like ?)
</code></pre>

<p><br /></p>

<h4 id="LocalDateTime,LocalDateandLocalTimequeriesID">LocalDateTime, LocalDate and LocalTime queries</h4>

<p><br /></p>

<p>LocalDateTime, LocalDate and LocalTime queries are supported.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void showSearchOnLocalDateTime() {
    LocalDateTime born1 = LocalDateTime.of(1990, 1, 1, 1, 1, 1);
    LocalDateTime born2 = LocalDateTime.of(1990, 1, 1, 1, 1, 2);
    LocalDateTime born3 = LocalDateTime.of(1990, 1, 1, 1, 1, 3);
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John", "born", born1);
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peter", "born", born2);
    Vertex paul = this.sqlgGraph.addVertex(T.label, "Person", "name", "Paul", "born", born3);
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V().hasLabel("Person")
            .has("born", P.eq(born1))
            .toList();
    assertEquals(1, persons.size());
    assertEquals(john, persons.get(0));

    persons = this.sqlgGraph.traversal().V().hasLabel("Person")
            .has("born", P.between(LocalDateTime.of(1990, 1, 1, 1, 1, 1), LocalDateTime.of(1990, 1, 1, 1, 1, 3)))
            .toList();
    //P.between is inclusive to exclusive
    assertEquals(2, persons.size());
    assertTrue(persons.contains(john));
    assertTrue(persons.contains(peter));
}
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."born" AS "alias2",
    "public"."V_Person"."name" AS "alias3"
FROM
    "public"."V_Person"
WHERE
    ( "public"."V_Person"."born" = ?)

SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."born" AS "alias2",
    "public"."V_Person"."name" AS "alias3"
FROM
    "public"."V_Person"
WHERE
    ( "public"."V_Person"."born" &gt;= ?) AND ( "public"."V_Person"."born" &lt; ?)
</code></pre>

<p><br /></p>

<h3 id="OrderID">Order</h3>

<p><br /></p>

<p>Sqlg optimizes the OrderGlobalStep if the data that the order applies to can be retrieved in one sql statement.
If not then order the ordering occurs in java via the OrderGlobalStep as per normal.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void testOrderBy() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "a");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "b");
    Vertex a3 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "c");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "a");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "b");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "c");
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; result = this.sqlgGraph.traversal().V().hasLabel("A")
            .order().by("name", Order.incr).by("surname", Order.decr)
            .toList();

    assertEquals(6, result.size());
    assertEquals(a3, result.get(0));
    assertEquals(a2, result.get(1));
    assertEquals(a1, result.get(2));
    assertEquals(b3, result.get(3));
    assertEquals(b2, result.get(4));
    assertEquals(b1, result.get(5));
}
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_A"."ID" AS "alias1",
    "public"."V_A"."surname" AS "alias2",
    "public"."V_A"."name" AS "alias3"
FROM
    "public"."V_A"
ORDER BY
     "alias3" ASC,
     "alias2" DESC
</code></pre>

<p><br /></p>

<h3 id="RepeatStepID">RepeatStep</h3>

<p><br /></p>

<p>Sqlg optimizes the RepeatStep so long as the <code class="language-java">until</code> modulator is not present. 
<code class="language-java">RepeatStep</code> can be optimized with the modulator <code class="language-java">emit</code> and <code class="language-java">times</code>.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void showRepeat() {
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    Vertex peterski = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peterski");
    Vertex paul = this.sqlgGraph.addVertex(T.label, "Person", "name", "Paul");
    Vertex usa = this.sqlgGraph.addVertex(T.label, "Country", "name", "USA");
    Vertex russia = this.sqlgGraph.addVertex(T.label, "Country", "name", "Russia");
    Vertex washington = this.sqlgGraph.addVertex(T.label, "City", "name", "Washington");
    john.addEdge("lives", usa);
    peterski.addEdge("lives", russia);
    usa.addEdge("capital", washington);
    this.sqlgGraph.tx().commit();

    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V()
        .hasLabel("Person")
        .emit().times(2).repeat(__.out("lives", "capital"))
        .path().by("name")
        .toList();
    for (Path path : paths) {
        System.out.println(path);
    }
}

Output:

[John]
[John, USA]
[John, USA, Washington]
[Peterski]
[Peterski, Russia]
[Paul]
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_City"."ID" AS "alias1",
    "public"."V_City"."name" AS "alias2",
    "public"."V_Person"."ID" AS "alias3",
    "public"."V_Person"."name" AS "alias4",
    "public"."V_Country"."ID" AS "alias5",
    "public"."V_Country"."name" AS "alias6",
    "public"."V_City"."ID" AS "alias7",
    "public"."V_City"."name" AS "alias8",
    "public"."E_lives"."ID" AS "alias9"
FROM
    "public"."V_Person" LEFT JOIN
    "public"."E_lives" ON "public"."V_Person"."ID" = "public"."E_lives"."public.Person__O" LEFT JOIN
    "public"."V_Country" ON "public"."E_lives"."public.Country__I" = "public"."V_Country"."ID" LEFT JOIN
    "public"."E_capital" ON "public"."V_Country"."ID" = "public"."E_capital"."public.Country__O" LEFT JOIN
    "public"."V_City" ON "public"."E_capital"."public.City__I" = "public"."V_City"."ID"
</code></pre>

<p>The <code class="language-java">RepeatStep</code> together with the <code class="language-java">emit</code> modulater is an optimized way to retrieve whole sub-graphs with one hit to the db.</p>

<p><strong>Note:</strong> The generated sql uses a <code class="language-java">left join</code> if the repeat statements has an <code class="language-java">emit</code> modulator.</p>

<p><br /></p>

<h2 id="BatchmodeID">Batch mode</h2>

<p><br /></p>

<p>Postgres is significantly slower than HSQLDB. This is expected as Postgres runs as a server and suffers from latency. 
HSQLDB shines in embedded mode. (HSQLDB has not been tested in server mode!)</p>

<p>Sqlg supports various batch modes. Batch modes are only implemented on Postgresql.
Batch mode is activated on the transaction object itself. After every <code class="language-java">commit</code> batchMode needs to be reactivated.</p>

<h4 id="ExamplePostgresqlID">Example Postgresql</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testBatchMode() {
    this.sqlgGraph.tx().batchModeOn();
    for (int i = 0; i &lt; 1000000; i++) {
        Vertex person1 = this.sqlgGraph.addVertex(T.label, "Person", "name", "a" + i);
        Vertex person2 = this.sqlgGraph.addVertex(T.label, "Person", "name", "b" + i);
        person1.addEdge("friend", person2, "context", 1);
        if (i != 0 &amp;&amp; i % 100000 == 0) {
            this.sqlgGraph.tx().commit();
            this.sqlgGraph.tx().batchModeOn();
        }
    }
    this.sqlgGraph.tx().commit();
}
</code></pre>

<p>With <code class="language-java">batchMode</code> on Sqlg will cache all modifications to the graph and on <code class="language-java">commit</code> execute bulk sql statements.
This has a significant improvement of performance.</p>

<p><br /></p>

<h2 id="PerformanceIndicatorID">Performance Indicator</h2>

<p><br /></p>

<p>Below are some fairly trivial examples using Sqlg, the purpose of which is to give an indication of the performance that can be
expected from Sqlg.</p>

<p>All tests were run on a standard laptop with the following specs.</p>

<ul>
<li>Intel(R) Core(TM) i7-4800MQ CPU @ 2.70GHz</li>
<li>500G Solid state drive</li>
</ul>

<p>Running TinkerPop's <code class="language-java">StructurePerformanceTest</code> produces the following output</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">WriteToIO.writeGraphSON: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 1.42 [+- 1.82]...
WriteToIO.writeKryo: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 0.70 [+- 0.11]...
WriteToIO.writeGraphML: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 0.77 [+- 0.06]...
WriteToGraph.writeEmptyVertices: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.31 [+- 0.43]...
WriteToGraph.writeEmptyVerticesAndEdges: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 11.52 [+- 0.63]...
ReadFromGraph.readAllProperties: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 4.26 [+- 0.97]...
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">WriteToIO.writeGraphSON: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.62 [+- 0.46]...
WriteToIO.writeKryo: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.64 [+- 0.11]...
WriteToIO.writeGraphML: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 4.24 [+- 0.10]...
WriteToGraph.writeEmptyVertices: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 14.53 [+- 0.19]...
WriteToGraph.writeEmptyVerticesAndEdges: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 48.64 [+- 0.41]...
ReadFromGraph.readAllProperties: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 16.00 [+- 0.35]...
</code></pre>

<h3 id="Sometrivialexamples.ID">Some trivial examples.</h3>

<h4 id="Create10000objects,eachwith2propertiesID">Create 10000 objects, each with 2 properties</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testAddPersons() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 0; i &lt; 10000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "prop1", "property1", "prop2", "property2");
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();
    Assert.assertEquals(Long.valueOf(10000), this.sqlgGraph.V().has(T.label, "Person").count().next());
    stopWatch.stop();
    System.out.println("Time to read: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:00.672
Time to read: 0:00:00.124
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:01.955
Time to read: 0:00:00.117
</code></pre>

<p>Note that the Postgres read time is roughly equivalent to that of HSQLDB. This is because in the above test there is only one call to
the database. Postgres itself is fast, however round trips between client and server are expensive.</p>

<h4 id="Create10001Persons,eachwith2propertiesandonefriendID">Create 10001 Persons, each with 2 properties and one friend</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testAddPersonAndFriends() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    Vertex previous = this.sqlgGraph.addVertex(T.label, "Person", "name", "first");

    for (int i = 0; i &lt; 10000; i++) {
        Vertex current = this.sqlgGraph.addVertex(T.label, "Person", "name", "current" + i);
        previous.addEdge("friend", current);
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();
    List&lt;Vertex&gt; persons = this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").toList();
    Map&lt;Vertex, List&lt;Vertex&gt;&gt; friendMap = new HashMap&lt;&gt;();
    persons.forEach(
            p -&gt; friendMap.put(p, p.in("friend").toList())
    );
    Assert.assertEquals(10001, friendMap.size());
    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:02.095
Time to read all vertices: 0:00:01.138
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:04.810
Time to read all vertices: 0:00:09.177
</code></pre>

<p>To retrieve the friends 1001 calls are made made. Postgres is significantly slower in this case.</p>

<h4 id="Postgres,Create1000000PersonsandDogswithapetedge.BatchModeon.ID">Postgres, Create 1 000 000 Persons and Dogs with a pet edge. BatchMode on.</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testPostgresBatchMode() {
    this.sqlgGraph.tx().batchModeOn();
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 1; i &lt; 1000001; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex dog = this.sqlgGraph.addVertex(T.label, "Dog", "name", "snowy" + i);
        person.addEdge("pet", dog);
        if (1 % 100000 == 0) {
            this.sqlgGraph.tx().commit();
            this.sqlgGraph.tx().batchModeOn();
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();

    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").count().next().intValue());
    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Dog").count().next().intValue());

    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:51.681
Time to read all vertices: 0:00:16.130
</code></pre>

<h4 id="HSQLDB,Create1000000PersonsandDogswithapetedge.ID">HSQLDB, Create 1 000 000 Persons and Dogs with a pet edge.</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testHsqldbLargeLoad() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 1; i &lt; 1000001; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex dog = this.sqlgGraph.addVertex(T.label, "Dog", "name", "snowy" + i);
        person.addEdge("pet", dog);
        if (i % 100000 == 0) {
            this.sqlgGraph.tx().commit();
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();

    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").count().next().intValue());
    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Dog").count().next().intValue());

    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:02:32.435
Time to read all vertices: 0:00:19.026
</code></pre>


        </div>
    </div>
    <hr>
    <footer class="pull-right">
        <p>100% open source. Licensed under the Apache Software License 2.0</p>
    </footer>

</div>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script src="javascripts/offcanvas.js"></script>
<script src="javascripts/prettify.js"></script>

<script type='text/javascript'>

    $(document).ready(function () {

        $('#sidebar').affix(
                {
                    offset: {
                        top: 40
                    }
                }
        );

        var $body = $(document.body);
        var navHeight = $('.navbar').outerHeight(true) + 10;

        $body.scrollspy({
            target: '#leftcol',
            offset: navHeight
        });

        /* smooth scrolling sections */
        $('a[href*=#]:not([href=#])').click(function () {
            if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
                var target = $(this.hash);
                target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
                if (target.length) {
                    $('html,body').animate({
                        scrollTop: target.offset().top - 50
                    }, 1000);
                    return false;
                }
            }
        });

    });

    prettyPrint();

</script>

</body>
</html>
