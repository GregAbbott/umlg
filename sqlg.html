<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="../../assets/ico/favicon.ico">

    <title>Sqlg</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- UMLG doc style -->
    <link href="stylesheets/umlg-doc.css" rel="stylesheet">

    <!-- Syntax Highlighter -->
    <link href="stylesheets/prettify.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body data-spy="scroll" data-target="#affix-nav">
<header class="navbar navbar-fixed-top navbar-inverse" role="banner">
    <div class="container">
        <div class="navbar-header">
            <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="sqlg.html" class="navbar-brand">Sqlg</a>
        </div>
        <nav class="collapse navbar-collapse" role="navigation">
            <ul class="nav navbar-nav pull-right">
                <li>
                    <a href="https://github.com/pietermartin/sqlg">Github</a>
                </li>
            </ul>
        </nav>
    </div>
</header>

<!-- Begin Body -->
<div class="container umlgcontainer">
    <div class="row">
        <div class="col-md-3" id="leftcol">
            <div class="bs-docs-sidebar hidden-print" role="complementary">
                <ul class="nav bs-docs-sidebar" id="sidebar">
                    <li class="active"><a href="#IntroductionID">Introduction</a><ul class="nav">
<li><a href="#TinkerPopsupportedfeaturesID">TinkerPop supported features</a></li></ul>
</li><li><a href="#GettingStartedID">Getting Started</a><ul class="nav">
<li><a href="#MavenID">Maven</a></li><li><a href="#GremlinConsoleID">Gremlin Console</a></li></ul>
</li><li><a href="#DatatypesID">Data types</a></li><li><a href="#ArchitectureID">Architecture</a><ul class="nav">
<li><a href="#VertextablesID">Vertex tables</a></li><li><a href="#EdgetablesID">Edge tables</a></li><li><a href="#TinkerPop-modernID">TinkerPop-modern</a></li><li><a href="#NamespacingandSchemasID">Namespacing and Schemas</a></li></ul>
</li><li><a href="#IndexesID">Indexes</a></li><li><a href="#SchemacreationID">Schema creation</a></li><li><a href="#TopologyID">Topology</a></li><li><a href="#MultipleJvmID">Multiple Jvm</a></li><li><a href="#GremlinID">Gremlin</a><ul class="nav">
<li><a href="#PredicatesID">Predicates </a><ul class="nav">
<li><a href="#ComparepredicateID">Compare predicate</a></li><li><a href="#ContainspredicateID">Contains predicate </a></li><li><a href="#TextpredicateID">Text predicate</a></li><li><a href="#DateTimequeriesID">DateTime queries</a></li></ul>
</li><li><a href="#OrderID">Order</a></li><li><a href="#RepeatStepID">RepeatStep</a></li></ul>
</li><li><a href="#BatchmodeID">Batch mode</a><ul class="nav">
<li><a href="#NormalbatchmodeID">Normal batch mode</a></li><li><a href="#StreamingbatchmodeID">Streaming batch mode</a></li><li><a href="#StreamingwithlockbatchmodeID">Streaming with lock batch mode</a></li></ul>
</li>
                </ul>
            </div>
        </div>
        <div class="col-md-9">

            <p class="pull-right visible-xs">
                <button type="button" class="btn btn-primary btn-xs" data-toggle="offcanvas">Toggle nav</button>
            </p>
            <!-- Sqlg -->

<h2 id="IntroductionID">Introduction</h2>

<p><strong>Sqlg</strong> is a implementation of <a href="https://github.com/tinkerpop/tinkerpop3">TinkerPop3</a> on a <a href="http://en.wikipedia.org/wiki/Relational_database_management_system">RDBMS</a>.
Currently <a href="http://hsqldb.org/">HSQLDB</a> and <a href="http://www.postgresql.org/">Postgresql</a> are supported.</p>

<p>Sqlg has a <a href="https://groups.google.com/forum/?hl=en#!forum/sqlg">Google Group</a>.</p>

<h3 id="TinkerPopsupportedfeaturesID">TinkerPop supported features</h3>

<p>Sqlg version 1.2.0 runs on TinkerPop 3.2.0-incubating</p>

<p>Sqlg passes TinkerPop's <code class="language-java">StructureStandardSuite</code> and <code class="language-java">ProcessStandardSuite</code> test suites.</p>

<p>Graph Features <strong>not</strong> implemented.</p>

<ul>
<li>Computer</li>
<li>ThreadedTransactions</li>
<li>Variables</li>
</ul>

<p>Vertex Features <strong>not</strong> implemented.</p>

<ul>
<li>MultiProperties</li>
<li>MetaProperties</li>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>StringIds</li>
<li>UuidIds</li>
<li>CustomIds</li>
<li>AnyIds</li>
</ul>

<p>Edge Features <strong>not</strong> implemented.</p>

<ul>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>StringIds</li>
<li>UuidIds</li>
<li>CustomIds</li>
<li>AnyIds</li>
</ul>

<p>Vertex property features <strong>not</strong> implemented.</p>

<ul>
<li>AddProperty</li>
<li>RemoveProperty</li>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>StringIds</li>
<li>UuidIds</li>
<li>CustomIds</li>
<li>AnyIds</li>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<p>Edge property feature <strong>not</strong> implemented.</p>

<ul>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<h2 id="GettingStartedID">Getting Started</h2>

<p><br /></p>

<h3 id="MavenID">Maven</h3>

<p><br /></p>

<p>Maven coordinates,</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-hsqldb&lt;/artifactId&gt;
    &lt;version&gt;1.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-postgres&lt;/artifactId&gt;
    &lt;version&gt;1.2.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Sqlg is designed to run as a singleton that can be shared among multiple threads. You can instantiate Sqlg using the standard
tinkerpop3 static constructors.</p>

<ul>
<li><code class="language-java">SqlgGraph.open(final Configuration configuration)</code></li>
<li><code class="language-java">SqlgGraph.open(final String pathToSqlgProperties)</code></li>
</ul>

<p>The configuration object requires the following properties.</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:hsqldb:file:/tmp/sqlg
jdbc.username=SA
jdbc.password=
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******
</code></pre>

<p>In the case of Postgresql the database must already exist.</p>

<p>If you want to run the TinkerPop tests on Postgresql you need to create the various databases that are used.
These are,</p>

<ul>
<li>g1</li>
<li>g2</li>
<li>readGraph</li>
<li>standard</li>
<li>temp</li>
<li>temp1</li>
<li>temp2</li>
<li>subgraph</li>
<li>prototype</li>
<li>target</li>
</ul>

<p><br /></p>

<h3 id="GremlinConsoleID">Gremlin Console</h3>

<p><br /></p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">[pieter@pieter-laptop bin]$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.server
plugin activated: tinkerpop.utilities
plugin activated: tinkerpop.tinkergraph
gremlin&gt; :install org.umlg sqlg-hsqldb 1.2.0-SNAPSHOT
log4j:WARN No appenders could be found for logger (org.apache.tinkerpop.gremlin.groovy.util.DependencyGrabber).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
==&gt;Loaded: [org.umlg, sqlg-hsqldb, 1.2.0-SNAPSHOT]
gremlin&gt; :plugin list
==&gt;tinkerpop.server[active]
==&gt;tinkerpop.gephi
==&gt;tinkerpop.utilities[active]
==&gt;tinkerpop.sugar
==&gt;tinkerpop.credentials
==&gt;tinkerpop.tinkergraph[active]
==&gt;sqlg.hsqldb
gremlin&gt; :plugin use sqlg.hsqldb
==&gt;sqlg.hsqldb activated
gremlin&gt; graph = SqlgGraph.open('pathTo/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g = graph.traversal()
==&gt;sqlggraphtraversalsource[sqlggraph[SqlGraph] (jdbc:hsqldb:file:src/test/db/sqlgraphdb), standard]
gremlin&gt; graph.io(graphml()).readGraph('pathTo/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;808
gremlin&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">[pieter@pieter-laptop bin]$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.server
plugin activated: tinkerpop.utilities
plugin activated: tinkerpop.tinkergraph
gremlin&gt; :install org.umlg sqlg-postgres 1.2.0-SNAPSHOT
log4j:WARN No appenders could be found for logger (org.apache.tinkerpop.gremlin.groovy.util.DependencyGrabber).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
==&gt;Loaded: [org.umlg, sqlg-postgres, 1.2.0-SNAPSHOT]
gremlin&gt; :plugin list
==&gt;tinkerpop.server[active]
==&gt;tinkerpop.gephi
==&gt;tinkerpop.utilities[active]
==&gt;tinkerpop.sugar
==&gt;tinkerpop.credentials
==&gt;tinkerpop.tinkergraph[active]
==&gt;sqlg.postgres
gremlin&gt; :plugin use sqlg.postgres
==&gt;sqlg.postgres activated
gremlin&gt; graph = SqlgGraph.open('pathTo/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g = graph.traversal()
==&gt;sqlggraphtraversalsource[sqlggraph[SqlGraph] (jdbc:postgresql://localhost:5432/sqlgraphdb), standard]
gremlin&gt; graph.io(graphml()).readGraph('pathTo/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;808
gremlin&gt;
</code></pre>

<p><br /></p>

<h2 id="DatatypesID">Data types</h2>

<p><br /></p>

<div>
<table class="table table-striped table-bordered table-small">
    <thead>
        <tr>
            <th>Java</th>
            <th>HSQLDB</th>
            <th>Postgresql</th>
        </tr>
    </thead>
    <tbody>
        </tr>
            <td><small>Boolean</small></td>
            <td><small>BOOLEAN</small></td>
            <td><small>BOOLEAN</small></td>
        </tr>
        <tr>
            <td><small>Byte</small></td>
            <td><small>TINYINT</small></td>
            <td><small><strong>Not supported</strong></small></td>
        </tr>
        <tr>
            <td><small>Short</small></td>
            <td><small>SMALLINT</small></td>
            <td><small>SMALLINT</small></td>
        </tr>
        <tr>
            <td><small>Integer</small></td>
            <td><small>INTEGER</small></td>
            <td><small>INTEGER</small></td>
        </tr>
        <tr>
            <td><small>Long</small></td>
            <td><small>BIGINT</small></td>
            <td><small>BIGINT</small></td>
        </tr>
        <tr>
            <td><small>Float</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>REAL</small></td>
        </tr>
        <tr>
            <td><small>Double</small></td>
            <td><small>DOUBLE</small></td>
            <td><small>DOUBLE PRECISION</small></td>
        </tr>
        <tr>
            <td><small>String</small></td>
            <td><small>LONGVARCHAR</small></td>
            <td><small>TEXT</small></td>
        </tr>
        <!-- Arrays -->
        <tr>
            <td><small>Boolean[]</small></td>
            <td><small>BOOLEAN ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>BOOLEAN[]</small></td>
        </tr>
        <tr>
            <td><small>Byte[]</small></td>
            <td><small>LONGVARBINARY</small></td>
            <td><small>BYTEA</small></td>
        </tr>
        <tr>
            <td><small>Short[]</small></td>
            <td><small>SMALLINT ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>SMALLINT[]</small></td>
        </tr>
        <tr>
            <td><small>Integer[]</small></td>
            <td><small>INTEGER ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>INTEGER[]</small></td>
        </tr>
        <tr>
            <td><small>Long[]</small></td>
            <td><small>BIGINT ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>BIGINT[]</small></td>
        </tr>
        <tr>
            <td><small>Float[]</small></td>
            <td><small>Not supported</small></td>
            <td><small>REAL[]</small></td>
        </tr>
        <tr>
            <td><small>Double[]</small></td>
            <td><small>DOUBLE ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>DOUBLE PRECISION[]</small></td>
        </tr>
        <tr>
            <td><small>String[]</small></td>
            <td><small>LONGVARCHAR ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>TEXT[]</small></td>
        </tr>
        <tr>
            <td><small>java.time.LocalDateTime</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE</small></td>
        </tr>
        <tr>
            <td><small>java.time.LocalDate</small></td>
            <td><small>DATE</small></td>
            <td><small>DATE</small></td>
        </tr>
        <tr>
            <td><small>java.time.LocalTime</small></td>
            <td><small>TIME WITH TIME ZONE</small></td>
            <td><small>TIME WITH TIME ZONE</small></td>
        </tr>
        <tr>
            <td><small>java.time.ZonedDateTime</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE<br /> LONGVARCHAR</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE<br /> TEXT</small></td>
        </tr>
        <tr>
            <td><small>java.time.Period</small></td>
            <td><small>INTEGER<br /> INTEGER<br /> INTEGER</small></td>
            <td><small>INTEGER<br /> INTEGER<br /> INTEGER</small></td>
        </tr>
        <tr>
            <td><small>java.time.Duration</small></td>
            <td><small>BIGINT<br /> INTEGER</small></td>
            <td><small>BIGINT<br /> INTEGER</small></td>
        </tr>
        <tr>
            <td><small>java.time.LocalDateTime[]</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE[]</small></td>
        </tr>
        <tr>
            <td><small>java.time.LocalDate[]</small></td>
            <td><small>DATE ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>DATE[]</small></td>
        </tr>
        <tr>
            <td><small>java.time.LocalTime[]</small></td>
            <td><small>TIME WITH TIME ZONE ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>TIME WITH TIME ZONE[]</small></td>
        </tr>
        <tr>
            <td><small>java.time.ZonedDateTime[]</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE ARRAY DEFAULT ARRAY[]<br \> LONGVARCHAR ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>TIMESTAMP WITH TIME ZONE[]<br \> TEXT[]</small></td>
        </tr>
        <tr>
            <td><small>java.time.Period[]</small></td>
            <td><small>INTEGER ARRAY DEFAULT ARRAY[]<br /> INTEGER ARRAY DEFAULT ARRAY[]<br /> INTEGER ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>INTEGER[]<br /> INTEGER[]<br /> INTEGER[]</small></td>
        </tr>
        <tr>
            <td><small>java.time.Duration[]</small></td>
            <td><small>BIGINT ARRAY DEFAULT ARRAY[]<br /> INTEGER ARRAY DEFAULT ARRAY[]</small></td>
            <td><small>BIGINT[]<br /> INTEGER[]</small></td>
        </tr>
        <tr>
            <td><small>com.fasterxml.jackson.databind.JsonNode</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>JSONB</small></td>
        </tr>
        <tr>
            <td><small>com.fasterxml.jackson.databind.JsonNode[]</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>JSONB[]</small></td>
        </tr>
        <tr>
            <td><small>org.postgis.Point</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>geometry(POINT)</small></td>
        </tr>
        <tr>
            <td><small>org.umlg.sqlg.gis.GeographyPoint</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>geography(POINT, 4326)</small></td>
        </tr>
        <tr>
            <td><small>org.postgis.LineString</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>geometry(LINESTRING)</small></td>
        </tr>
        <tr>
            <td><small>org.postgis.Polygon</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>geometry(POLYGON)</small></td>
        </tr>
        <tr>
            <td><small>org.umlg.sqlg.gis.GeographyPolygon</small></td>
            <td><small><strong>Not supported</strong></small></td>
            <td><small>geography(POLYGON, 4326)</small></td>
        </tr>
    </tbody>
</table>
</div>

<p><strong>NOTE</strong> <code class="language-java">java.time.LocalTime</code> drops the nano second precision.</p>

<p><br /></p>

<h2 id="ArchitectureID">Architecture</h2>

<p><br /></p>

<p>With the coming of vertex labels to TinkerPop the mapping of TinkerPop's graph semantics to that of a RDBMS became natural and useful.</p>

<h3 id="VertextablesID">Vertex tables</h3>

<p>Every unique vertex label maps to a table. Vertex tables are prefixed with a <code class="language-java">V_</code>. i.e. <code class="language-java">V_Person</code>. The vertex table
stores the vertex's properties.</p>

<h3 id="EdgetablesID">Edge tables</h3>

<p>Every unique edge label maps to a table. Edge tables are prefixed with a <code class="language-java">E_</code>. i.e. <code class="language-java">E_friend</code>. The edge table stores
each edge's adjacent vertex ids and the edge properties. The column corresponding to each adjacent vertex id (<code class="language-java">IN</code> and <code class="language-java">OUT</code>)
has a foreign key to the adjacent vertex's table.</p>

<p>From a rdbms' perspective each edge table is the classic <code class="language-java">many to many</code> join table between vertices.</p>

<h3 id="TinkerPop-modernID">TinkerPop-modern</h3>

<p>Taken from <a href="http://tinkerpop.incubator.apache.org/docs/3.1.0-incubating/#intro">TinkerPop</a></p>

<p><img src="images/sqlg/tinkerpop-modern-graph.png" alt="image of tinkerpop-classic" title="" /></p>

<p><strong>ER Diagram</strong></p>

<p><img src="images/sqlg/tinkerpop-modern-er.png" alt="image of tinkerpop-classic" title="" /></p>

<p><strong>V_person</strong></p>

<p><img src="images/sqlg/V_person.png" alt="image of tinkerpop-classic" title="" /></p>

<p><strong>V_software</strong></p>

<p><img src="images/sqlg/V_software.png" alt="image of tinkerpop-classic" title="" /></p>

<p><strong>E_knows</strong></p>

<p><img src="images/sqlg/E_knows.png" alt="image of tinkerpop-classic" title="" /></p>

<p><strong>E_created</strong></p>

<p><img src="images/sqlg/E_created.png" alt="image of tinkerpop-classic" title="" /></p>

<h3 id="NamespacingandSchemasID">Namespacing and Schemas</h3>

<p>Many RDBMS databases have the notion of a <code class="language-java">schema</code> as a namespace for tables. Sqlg supports schemas
for vertex labels. Distinct schemas for edge tables are unnecessary as edge tables are created in the schema of the adjacent <code class="language-java">out</code> vertex.
By default schemas for vertex tables go into the underlying databases' default schema. For Postgresql and hsqldb this
is the <code class="language-java">public</code> schema.</p>

<p>To specify the schema for a label Sqlg uses the dot <code class="language-java">.</code> notation.</p>

<pre class="prettyprint"><code class="language-java">Vertex john = this.sqlgGraph.addVertex(T.label, "manager", "name", "john");
Vertex palace1 = this.sqlgGraph.addVertex(T.label, "continent.house", "name", "palace1");
Vertex corrola = this.sqlgGraph.addVertex(T.label, "fleet.car", "model", "corrola");
palace1.addEdge("managedBy", john);
corrola.addEdge("owner", john);
</code></pre>

<p>This will create a table <code class="language-java">V_manager</code> in the <code class="language-java">public</code> (default) schema. Table <code class="language-java">V_house</code> is in a <code class="language-java">continent</code> schema and table <code class="language-java">V_car</code>
is in a <code class="language-java">fleet</code> schema. For the edges a <code class="language-java">E_managedBy</code> table is created in the <code class="language-java">continent</code> schema and a <code class="language-java">E_owner</code> table in the <code class="language-java">fleet</code> schema.</p>

<p><strong>Schemas</strong></p>

<p><img src="images/sqlg/schemas.png" alt="image of tinkerpop-classic" title="" />
<img src="images/sqlg/continent.png" alt="image of tinkerpop-classic" title="" />
<img src="images/sqlg/fleet.png" alt="image of tinkerpop-classic" title="" />
<img src="images/sqlg/public.png" alt="image of tinkerpop-classic" title="" /></p>

<p><br /></p>

<h2 id="IndexesID">Indexes</h2>

<p><br /></p>

<p>Sqlg supports basic indexing.</p>

<p><code class="language-java">org.umlg.sqlg.structure.SqlgGraph</code> has two methods on it to create indexes one for vertices and one for edges.</p>

<ul>
<li><code class="language-java">SqlgGraph.createVertexLabeledIndex(String label, Object... dummykeyValues)</code></li>
<li><code class="language-java">SqlgGraph.createEdgeLabeledIndex(String label, Object... dummykeyValues)</code></li>
</ul>

<p>The <code class="language-java">dummykeyValues</code> are required to indicate to Sqlg the name and type of the property. The type is needed when
the column does not yet exist and Sqlg needs to create it.</p>

<p>Outside of creating the index Sqlg has no further direct interaction with the index. However gremlin queries with a
<code class="language-java">has</code> step will translate to a sql <code class="language-java">where</code> clause. If an index has been created on the property of the <code class="language-java">has</code> step then
the underlying rdbms will utilize that index on that property's column.</p>

<p>The index does not need to be created upfront. It can be added any time.</p>

<p><strong>Example illustrating indexes</strong></p>

<pre class="prettyprint"><code class="language-java">@Test
public void testIndexOnVertex() throws SQLException {
    this.sqlgGraph.createVertexLabeledIndex("Person", "name", "dummy");
    this.sqlgGraph.tx().commit();
    for (int i = 0; i &lt; 5000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "john" + i);
    }
    this.sqlgGraph.tx().commit();
    assertEquals(1, this.sqlgGraph.traversal().V().has(T.label, "Person").has("name", "john50").count().next(), 0);

    //Check if the index is being used
    Connection conn = this.sqlgGraph.tx().getConnection();
    Statement statement = conn.createStatement();
    ResultSet rs = statement.executeQuery("explain analyze SELECT * FROM \"public\".\"V_Person\" a WHERE a.\"name\" = 'john50'");
    assertTrue(rs.next());
    String result = rs.getString(1);
    System.out.println(result);
    assertTrue(result.contains("Index Scan") || result.contains("Bitmap Heap Scan"));
    statement.close();
    this.sqlgGraph.tx().rollback();
}

Output: "Bitmap Heap Scan on "V_Person" a  (cost=4.42..32.42 rows=18 width=40) (actual time=0.016..0.016 rows=1 loops=1)"
</code></pre>

<p><strong>Table definition (Postgresql)</strong></p>

<p><img src="images/sqlg/tableDefinition.png" alt="image of tinkerpop-classic" title="" /></p>

<p>In the above example, Sqlg created a table <code class="language-java">V_Person</code> with column <code class="language-java">name</code> and an index on the <code class="language-java">name</code> column.
Currently Sqlg only supports the default index. For Postgresql this is a <code class="language-java">Btree</code> index.</p>

<p>The output shows the result of a Postgresql query explain plan. The result shows that Postgresql does indeed utilize the index.</p>

<p>The gremlin query <code class="language-java">this.sqlgGraph.traversal().V().has(T.label, "Person").has("name1", "john50")</code> will utilize the index on the <code class="language-java">name</code> field.</p>

<p><br /></p>

<h2 id="SchemacreationID">Schema creation</h2>

<p><br /></p>

<p>Sqlg creates the schema lazily. This is great, but comes with serious caveats.</p>

<p><strong>HSQLDB</strong> does not support transactional schema creation. HSQLDB automatically commits any schema creation/alter command
and immediately starts a new transaction.
This can have some rather unfortunate consequences, as HSQLDB will silently commit a user transaction thus invalidating
the user's transaction boundaries and semantics.</p>

<p><strong>Postgresql</strong> supports transactional schema creation/alter commands. The user's transaction semantics remain intact.
 However schema creation commands creates table level locks which increases the risk of deadlocks in a multi-threaded environment. 
 Sqlg manages a global lock for schema creation to prevent Postgresql from dead locking.
 If multiple jvm(s) are used then a Hazelcast distributed lock is used.</p>

<p><br /></p>

<h2 id="TopologyID">Topology</h2>

<p><br /></p>

<p>As of version 1.2.0 Sqlg stores the graph's topology (schema, meta data) natively. The topology is itself stored in the graph.
The topology is stored in the 'sqlg_schema' rdbms schema.</p>

<p><img src="images/sqlg/sqlg_topology.png" alt="image of sqlg-topology" title="" /></p>

<p>This is a uml diagram of TinkerPop's meta model.</p>

<p>The topology is itself being stored in the graph allows it to be queried using Gremlin.
To query the topology the <code class="language-java">TopologyStrategy</code> is used. To facilitate ease of use, <code class="language-java">SqlgGraph.topology()</code> method is added to enable the strategy.
Being able to query the topology is very helpful to understand a graph's structure.</p>

<p><strong>Example illustrating querying the topology</strong></p>

<pre class="prettyprint"><code class="language-java">[pieter@pieter-laptop bin]$ ./gremlin.sh 

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
plugin activated: tinkerpop.server
plugin activated: tinkerpop.utilities
plugin activated: sqlg.hsqldb
plugin activated: sqlg.postgres
plugin activated: tinkerpop.tinkergraph
gremlin&gt; :plugin use sqlg.postgres
==&gt;sqlg.postgres activated
gremlin&gt; graph = SqlgGraph.open('pathTo/sqlg.properties')
log4j:WARN No appenders could be found for logger (org.apache.commons.configuration.PropertiesConfiguration).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
==&gt;sqlggraph[SqlGraph] (jdbc:postgresql://localhost:5432/sqlgraphdb)
gremlin&gt; graph.io(graphml()).readGraph('pathTo/tinkerpop-modern.xml')
==&gt;null
gremlin&gt; t = graph.topology()
==&gt;sqlggraphtraversalsource[sqlggraph[SqlGraph] (jdbc:postgresql://localhost:5432/sqlgraphdb), standard]
gremlin&gt; t.V().hasLabel("sqlg_schema.schema").values("name")
==&gt;public
gremlin&gt; t.V().hasLabel("sqlg_schema.vertex").values("name")
==&gt;person
==&gt;software
gremlin&gt; t.V().hasLabel("sqlg_schema.vertex").has("name", "person").out("vertex_property").values("name")
==&gt;name
==&gt;age
gremlin&gt; t.V().hasLabel("sqlg_schema.vertex").has("name", "person").out("out_edges").values("name")
==&gt;knows
==&gt;created
gremlin&gt; t.V().hasLabel("sqlg_schema.vertex").has("name", "person").out("in_edges").values("name")
==&gt;knows
gremlin&gt; t.V().hasLabel("sqlg_schema.vertex").has("name", "software").out("in_edges").values("name")
==&gt;created
gremlin&gt; t.V().hasLabel("sqlg_schema.vertex").has("name", "person").out("out_edges").out("edge_property").values("name")
==&gt;weight
==&gt;weight
gremlin&gt; t.V().hasLabel("sqlg_schema.vertex").has("name", "software").out("vertex_property").values("name","type")
==&gt;name
==&gt;STRING
==&gt;lang
==&gt;STRING
</code></pre>

<p><strong>NOTE</strong></p>

<p>Sqlg will automatically upgrade versions prior to 1.2.0. It does so by reading the <code class="language-java">information_schema</code> tables and populating the <code class="language-java">sqlg_schema</code>.</p>

<p><br /></p>

<h2 id="MultipleJvmID">Multiple Jvm</h2>

<p><br /></p>

<p>It is possible to run many Sqlg instances pointing to the same underlying database. These instances can be in the same jvm
but is primarily intended for separate jvm(s) pointing to the same underlying database.</p>

<p>Sqlg caches database schema information. When multiple Sqlg instances point to the same database,
Sqlg uses <a href="http://hazelcast.com/">Hazelcast</a> as a distributed cache of the schema information.</p>

<p>To indicate to Sqlg that a <code class="language-java">Hazelcast</code> cluster is required  you must specify <code class="language-java">hazelcast.members=ipaddres1,ipaddres2,ipaddres3</code>
in the constructors configuration object. Hazelcast will then automatically set up the distributed cluster for the schema
information.</p>

<p><strong>Example Postgresql</strong></p>

<p><strong>Jvm 1</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******
hazelcast.members=127.0.0.1,127.0.0.2
</code></pre>

<p><strong>Jvm 2</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******
hazelcast.members=127.0.0.1,127.0.0.2
</code></pre>

<p><br /></p>

<h2 id="GremlinID">Gremlin</h2>

<p><br /></p>

<p>Sqlg has full support for gremlin.
However gremlin's fine grained 'graphy' nature results in very high latency. To overcome the high latency Sqlg optimizes 
gremlin by reducing the number of calls to the rdbms.</p>

<p>Sqlg optimizes gremlin by analyzing the steps and where possible combining them into a single SqlgGraphStepCompiled or SqlgVertexStepCompiled.</p>

<p><strong>NOTE</strong> This is an ongoing task as gremlin is a large language. </p>

<p>Consecutive GraphStep, VertexStep, EdgeVertexStep, EdgeOtherVertexStep, HasStep, RepeatStep and OrderGlobalStep are currently combined.
The combined step will then in turn generate the sql statements to retrieve the data. It attempts to retrieve the data in as few distinct sql statements as possible.</p>

<p><strong>NOTE:</strong> Turn sql logging on by setting <code class="language-java">log4j.logger.org.umlg.sqlg=debug</code></p>

<p><strong>Example illustrating high latency</strong></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showHighLatency() {
    Vertex easternUnion = this.sqlgGraph.addVertex(T.label, "Organization", "name", "EasternUnion");
    Vertex legal = this.sqlgGraph.addVertex(T.label, "Division", "name", "Legal");
    Vertex dispatch = this.sqlgGraph.addVertex(T.label, "Division", "name", "Dispatch");
    Vertex newYork = this.sqlgGraph.addVertex(T.label, "Office", "name", "NewYork");
    Vertex singapore = this.sqlgGraph.addVertex(T.label, "Office", "name", "Singapore");
    easternUnion.addEdge("organization_division", legal);
    easternUnion.addEdge("organization_division", dispatch);
    legal.addEdge("division_office", newYork);
    dispatch.addEdge("division_office", singapore);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
        .hasLabel("Organization")
        .out()
        .out();
    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; offices = traversal.toList();
    assertEquals(2, offices.size());
}

Before optimization:
[GraphStep([],vertex), HasStep([~label.eq(Organization)]), VertexStep(OUT,vertex), VertexStep(OUT,vertex)]

After optimization:
[SqlgGraphStepCompiled([],vertex)]
</code></pre>

<p>Without optimization the query <code class="language-java">this.sqlgGraph.traversal().V().hasLabel("Organization").out().out()</code> will result
in a number of database hits. First to get the organizations, then for each organization the divisions and then for each division the offices.
For an embedded db like HSQLDB this is still ok but for a database server like postgresql the performance impact is significant.</p>

<p>In the above example the GraphStep, HasStep and 2 VertexSteps are all combined into one step, SqlgGraphStepCompiled.</p>

<p>The before optimization output shows the steps that would have executed with if no optimization is performed. 
As the query only contains sequential optimizable steps they are all combined into one step. </p>

<p>The above example will retrieve the data in one sql query.</p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Office"."ID" AS "alias1",
    "public"."V_Office"."name" AS "alias2"
FROM
    "public"."V_Organization" INNER JOIN
    "public"."E_organization_division" ON "public"."V_Organization"."ID" = "public"."E_organization_division"."public.Organization__O" INNER JOIN
    "public"."V_Division" ON "public"."E_organization_division"."public.Division__I" = "public"."V_Division"."ID" INNER JOIN
    "public"."E_division_office" ON "public"."V_Division"."ID" = "public"."E_division_office"."public.Division__O" INNER JOIN
    "public"."V_Office" ON "public"."E_division_office"."public.Office__I" = "public"."V_Office"."ID"
</code></pre>

<p><br /></p>

<h3>Predicates</h3>

<p><br /></p>

<p>TinkerPop's <a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Compare.html">Compare</a> and 
<a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Contains.html">Contains</a> predicates are optimized 
to execute on the database.</p>

<p><br /></p>

<h4 id="ComparepredicateID">Compare predicate</h4>

<p><br /></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showComparePredicate() {
    Vertex easternUnion = this.sqlgGraph.addVertex(T.label, "Organization", "name", "EasternUnion");
    Vertex legal = this.sqlgGraph.addVertex(T.label, "Division", "name", "Legal");
    Vertex dispatch = this.sqlgGraph.addVertex(T.label, "Division", "name", "Dispatch");
    Vertex newYork = this.sqlgGraph.addVertex(T.label, "Office", "name", "NewYork");
    Vertex singapore = this.sqlgGraph.addVertex(T.label, "Office", "name", "Singapore");
    easternUnion.addEdge("organization_division", legal);
    easternUnion.addEdge("organization_division", dispatch);
    legal.addEdge("division_office", newYork);
    dispatch.addEdge("division_office", singapore);
    this.sqlgGraph.tx().commit();

    GraphTraversal&lt;Vertex, Vertex&gt; traversal = this.sqlgGraph.traversal().V()
        .hasLabel("Organization")
        .out()
        .out()
        .has("name", P.eq("Singapore"));
    System.out.println(traversal);
    traversal.hasNext();
    System.out.println(traversal);
    List&lt;Vertex&gt; offices = traversal.toList();
    assertEquals(1, offices.size());
    assertEquals(singapore, offices.get(0));
}
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Office"."ID" AS "alias1",
    "public"."V_Office"."name" AS "alias2"
FROM
    "public"."V_Organization" INNER JOIN
    "public"."E_organization_division" ON "public"."V_Organization"."ID" = "public"."E_organization_division"."public.Organization__O" INNER JOIN
    "public"."V_Division" ON "public"."E_organization_division"."public.Division__I" = "public"."V_Division"."ID" INNER JOIN
    "public"."E_division_office" ON "public"."V_Division"."ID" = "public"."E_division_office"."public.Division__O" INNER JOIN
    "public"."V_Office" ON "public"."E_division_office"."public.Office__I" = "public"."V_Office"."ID"
WHERE
    ( "public"."V_Office"."name" = ?)
</code></pre>

<p>The same pattern is used for all the 
<a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Compare.html">Compare</a> predicates.       </p>

<p><br /></p>

<h4>Contains predicate</h4>

<p><br /></p>

<p>Sqlg's implementation of <a href="http://tinkerpop.apache.org/javadocs/3.1.0-incubating/core/org/apache/tinkerpop/gremlin/process/traversal/Contains.html">Contains</a> is slightly more complex.
For HSQLDB a regular <code class="language-java">in</code> clause is used.</p>

<p>For Postgresql, instead of using a sql <code class="language-java">in</code> clause, i.e. <code class="language-java">where property in (?, ?...)</code> the values are bulk inserted into a temporary table and then a join to the temporary table is used
to constrain the results.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void showContainsPredicate() {
    List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(10000);
    for (int i = 0; i &lt; 10000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "number", i);
        numbers.add(i);
    }
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("number", P.within(numbers))
            .toList();

    assertEquals(10000, persons.size());
}
</code></pre>

<p>And the resulting sql on Postgresql,    </p>

<pre class="prettyprint"><code class="language-java">CREATE TEMPORARY TABLE "V_BULK_TEMP_EDGEzf++PItI"("ID" SERIAL PRIMARY KEY, "within" INTEGER) ON COMMIT DROP;
COPY "V_BULK_TEMP_EDGEzf++PItI" ("within") FROM stdin DELIMITER '   ';
SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."number" AS "alias2"
FROM
    "public"."V_Person"
INNER JOIN  "V_BULK_TEMP_EDGEzf++PItI" tmp1 on"public"."V_Person"."number" = tmp1.within
</code></pre>

<p>This pattern makes <code class="language-java">P.within</code> and <code class="language-java">p.without</code> very fast even with millions of values being passed into the query. 
Benchmarking shows that doing a join on a temporary table is always faster than using the <code class="language-java">in</code> clause. 
For the case of there being only one value Sqlg will use an <code class="language-java">equals</code> instead of a temporay table or an <code class="language-java">in</code> statement.</p>

<p><br /></p>

<h4 id="TextpredicateID">Text predicate</h4>

<p><br /></p>

<p>Sqlg includes its own Text predicate for full text queries.</p>

<ul>
<li>Text.contains (case sensitive string contains)</li>
<li>Text.ncontains (case sensitive string does not contain)</li>
<li>Text.containsCIS (case insensitive string contains)</li>
<li>Text.ncontainsCIS (case insensitive string does not contain)</li>
<li>Text.startsWith (case sensitive string starts with)</li>
<li>Text.nstartsWith (case sensitive string does not start with)</li>
<li>Text.endsWith (case sensitive string ends with)</li>
<li>Text.nendsWith (case sensitive string does not end with)</li>
</ul>

<p><br /></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showTextPredicate() {
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John XXX Doe");
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peter YYY Snow");
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V()
            .hasLabel("Person")
            .has("name", Text.contains("XXX")).toList();

    assertEquals(1, persons.size());
    assertEquals(john, persons.get(0));
}
</code></pre>

<p>And the resulting sql on Postgresql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."name" AS "alias2"
FROM
    "public"."V_Person"
WHERE
    ( "public"."V_Person"."name" like ?)
</code></pre>

<p><br /></p>

<h4 id="DateTimequeriesID">DateTime queries</h4>

<p><br /></p>

<p>LocalDateTime, LocalDate and LocalTime queries are supported.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void showSearchOnLocalDateTime() {
    LocalDateTime born1 = LocalDateTime.of(1990, 1, 1, 1, 1, 1);
    LocalDateTime born2 = LocalDateTime.of(1990, 1, 1, 1, 1, 2);
    LocalDateTime born3 = LocalDateTime.of(1990, 1, 1, 1, 1, 3);
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John", "born", born1);
    Vertex peter = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peter", "born", born2);
    Vertex paul = this.sqlgGraph.addVertex(T.label, "Person", "name", "Paul", "born", born3);
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; persons = this.sqlgGraph.traversal().V().hasLabel("Person")
            .has("born", P.eq(born1))
            .toList();
    assertEquals(1, persons.size());
    assertEquals(john, persons.get(0));

    persons = this.sqlgGraph.traversal().V().hasLabel("Person")
            .has("born", P.between(LocalDateTime.of(1990, 1, 1, 1, 1, 1), LocalDateTime.of(1990, 1, 1, 1, 1, 3)))
            .toList();
    //P.between is inclusive to exclusive
    assertEquals(2, persons.size());
    assertTrue(persons.contains(john));
    assertTrue(persons.contains(peter));
}
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."born" AS "alias2",
    "public"."V_Person"."name" AS "alias3"
FROM
    "public"."V_Person"
WHERE
    ( "public"."V_Person"."born" = ?)

SELECT
    "public"."V_Person"."ID" AS "alias1",
    "public"."V_Person"."born" AS "alias2",
    "public"."V_Person"."name" AS "alias3"
FROM
    "public"."V_Person"
WHERE
    ( "public"."V_Person"."born" &gt;= ?) AND ( "public"."V_Person"."born" &lt; ?)
</code></pre>

<p><br /></p>

<h3 id="OrderID">Order</h3>

<p><br /></p>

<p>Sqlg optimizes the OrderGlobalStep if the data that the order applies to can be retrieved in one sql statement.
If not then order the ordering occurs in java via the OrderGlobalStep as per normal.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void testOrderBy() {
    Vertex a1 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "a");
    Vertex a2 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "b");
    Vertex a3 = this.sqlgGraph.addVertex(T.label, "A", "name", "a", "surname", "c");
    Vertex b1 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "a");
    Vertex b2 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "b");
    Vertex b3 = this.sqlgGraph.addVertex(T.label, "A", "name", "b", "surname", "c");
    this.sqlgGraph.tx().commit();

    List&lt;Vertex&gt; result = this.sqlgGraph.traversal().V().hasLabel("A")
            .order().by("name", Order.incr).by("surname", Order.decr)
            .toList();

    assertEquals(6, result.size());
    assertEquals(a3, result.get(0));
    assertEquals(a2, result.get(1));
    assertEquals(a1, result.get(2));
    assertEquals(b3, result.get(3));
    assertEquals(b2, result.get(4));
    assertEquals(b1, result.get(5));
}
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_A"."ID" AS "alias1",
    "public"."V_A"."surname" AS "alias2",
    "public"."V_A"."name" AS "alias3"
FROM
    "public"."V_A"
ORDER BY
     "alias3" ASC,
     "alias2" DESC
</code></pre>

<p><br /></p>

<h3 id="RepeatStepID">RepeatStep</h3>

<p><br /></p>

<p>Sqlg optimizes the RepeatStep so long as the <code class="language-java">until</code> modulator is not present. 
<code class="language-java">RepeatStep</code> can be optimized with the modulator <code class="language-java">emit</code> and <code class="language-java">times</code>.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void showRepeat() {
    Vertex john = this.sqlgGraph.addVertex(T.label, "Person", "name", "John");
    Vertex peterski = this.sqlgGraph.addVertex(T.label, "Person", "name", "Peterski");
    Vertex paul = this.sqlgGraph.addVertex(T.label, "Person", "name", "Paul");
    Vertex usa = this.sqlgGraph.addVertex(T.label, "Country", "name", "USA");
    Vertex russia = this.sqlgGraph.addVertex(T.label, "Country", "name", "Russia");
    Vertex washington = this.sqlgGraph.addVertex(T.label, "City", "name", "Washington");
    john.addEdge("lives", usa);
    peterski.addEdge("lives", russia);
    usa.addEdge("capital", washington);
    this.sqlgGraph.tx().commit();

    List&lt;Path&gt; paths = this.sqlgGraph.traversal().V()
        .hasLabel("Person")
        .emit().times(2).repeat(__.out("lives", "capital"))
        .path().by("name")
        .toList();
    for (Path path : paths) {
        System.out.println(path);
    }
}

Output:

[John]
[John, USA]
[John, USA, Washington]
[Peterski]
[Peterski, Russia]
[Paul]
</code></pre>

<p>And the resulting sql,    </p>

<pre class="prettyprint"><code class="language-java">SELECT
    "public"."V_City"."ID" AS "alias1",
    "public"."V_City"."name" AS "alias2",
    "public"."V_Person"."ID" AS "alias3",
    "public"."V_Person"."name" AS "alias4",
    "public"."V_Country"."ID" AS "alias5",
    "public"."V_Country"."name" AS "alias6",
    "public"."V_City"."ID" AS "alias7",
    "public"."V_City"."name" AS "alias8",
    "public"."E_lives"."ID" AS "alias9"
FROM
    "public"."V_Person" LEFT JOIN
    "public"."E_lives" ON "public"."V_Person"."ID" = "public"."E_lives"."public.Person__O" LEFT JOIN
    "public"."V_Country" ON "public"."E_lives"."public.Country__I" = "public"."V_Country"."ID" LEFT JOIN
    "public"."E_capital" ON "public"."V_Country"."ID" = "public"."E_capital"."public.Country__O" LEFT JOIN
    "public"."V_City" ON "public"."E_capital"."public.City__I" = "public"."V_City"."ID"
</code></pre>

<p>The <code class="language-java">RepeatStep</code> together with the <code class="language-java">emit</code> modulater is an optimized way to retrieve whole sub-graphs with one hit to the db.</p>

<p><strong>NOTE</strong> The generated sql uses a <code class="language-java">left join</code> if the repeat statements has an <code class="language-java">emit</code> modulator.</p>

<p><br /></p>

<h2 id="BatchmodeID">Batch mode</h2>

<p><br /></p>

<p>Sqlg supports 3 distinct batch modes. Normal, streaming and streaming with lock. Batch modes are only implemented on Postgresql.
Batch mode is activated on the transaction object itself. After every <code class="language-java">commit</code>/<code class="language-java">flush</code> the batchMode needs to be reactivated.</p>

<p>Sqlg introduces an extra method on the transaction, <code class="language-java">flush()</code>. </p>

<ul>
<li>In normal batch mode <code class="language-java">flush()</code> will send all the data to Postgresql, assign id(s) and clear the cache.</li>
<li>In streaming mode <code class="language-java">flush()</code> will close the OutputStream that the data has been written to.</li>
<li>In streaming mode with lock <code class="language-java">flush()</code> will close the OutputStream that the data has been written to and assign id(s).</li>
</ul>

<p>The Postgresql <a href="http://www.postgresql.org/docs/9.4/static/sql-copy.html">copy</a> command is used to bulk insert data.</p>

<p><br /></p>

<h3 id="NormalbatchmodeID">Normal batch mode</h3>

<p><br /></p>

<p>In normal batch mode the standard TinkerPop modification api can be used. Normal batch mode caches all modifications in memory
and on <code class="language-java">commit()</code> or <code class="language-java">flush()</code> sends the modification to the server.</p>

<p>Because all modifications are held in memory it is important to call <code class="language-java">commit()</code> or <code class="language-java">flush()</code> to prevent <code class="language-java">OutOfMemoryError</code>.</p>

<p>In batch mode vertices and edges returned from <code class="language-java">Graph.addVertex</code> and <code class="language-java">vertex.addEdge</code> respectively do <strong>not</strong> yet have their id(s) assigned to them.
This is because the new vertices and edges are cached in memory and are only sent to Postgresql on <code class="language-java">commit()</code> or <code class="language-java">flush()</code>.
After <code class="language-java">commit()</code> or <code class="language-java">flush()</code> the new vertices and edges have their id(s) assigned.</p>

<p>The transaction must be manually placed in normal batch mode. i.e. <code class="language-java">Graph.tx().normalBatchModeOn()</code> must occur before any batch processing.
After every <code class="language-java">commit()</code> or <code class="language-java">flush()</code> the transaction reverts to a regular transaction and must be placed in normal batch mode again 
for batch processing to continue.</p>

<p>Vertices and edges can be created as per normal making normal batch mode very convenient.</p>

<p><strong>Example illustrating normal batch mode</strong></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showNormalBatchMode() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    this.sqlgGraph.tx().normalBatchModeOn();
    for (int i = 1; i &lt;= 10_000_000; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex car = this.sqlgGraph.addVertex(T.label, "Car", "name", "Dodge" + i);
        person.addEdge("drives", car);
        //To preserve memory commit or flush every so often
        if (i % 100_000 == 0) {
            this.sqlgGraph.tx().commit();
            this.sqlgGraph.tx().normalBatchModeOn();
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}

Time taken: 0:03:46.217
</code></pre>

<p><img src="images/sqlg/normalBatchModeMemory.png" alt="image of normal batch mode memory usage" title="" />
<br />
Normal batch mode memory usage. </p>

<p>Test executed with -Xmx2048m</p>

<p>Created 10 000 000 Persons each with a car. 20 000 000 vertices and 10 000 000 edges.
<br /></p>

<p><br /></p>

<h3 id="StreamingbatchmodeID">Streaming batch mode</h3>

<p><br /></p>

<p>Streaming batch writes any new vertex or edge immediately to Postgresql via its <code class="language-java">stdin</code> api. I.e. the data is written
directly to a Postgresql jdbc driver OutputStream.</p>

<p>Streaming batch mode does <strong>not</strong> use the <code class="language-java">Graph.addVertex</code> method. Instead <code class="language-java">Graph.streamVertex</code> is defined.</p>

<p>The transaction must be placed in streaming batch mode manually before any streaming batch modification can happen. <code class="language-java">Graph.tx().streamingBatchModeOn()</code>
After every <code class="language-java">commit()</code> or <code class="language-java">flush()</code> the transaction reverts to normal mode and must be placed into streaming batch mode again 
for streaming batch mode to continue.</p>

<p>The benefit of streaming mode is that the memory consumption is very low as nothing is cached. It is also somewhat faster than
the normal batch mode (+/- 25% faster).</p>

<p>However the caveat is that, per transaction/thread only one label/table can be written between consecutive calls to <code class="language-java">SqlgTransaction.flush()</code>. 
Further it is not possible to assign an id to the vertex or element. As such the <code class="language-java">SqlgGraph.streamVertex</code> method returns void.</p>

<p><strong>Example illustrating streaming batch mode</strong></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showStreamingBatchMode() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    //enable streaming mode
    this.sqlgGraph.tx().streamingBatchModeOn();
    for (int i = 1; i &lt;= 10_000_000; i++) {
        this.sqlgGraph.streamVertex(T.label, "Person", "name", "John" + i);
    }
    //flushing is needed before starting streaming Car. Only only one label/table can stream at a time.
    this.sqlgGraph.tx().flush();
    for (int i = 1; i &lt;= 10_000_000; i++) {
        this.sqlgGraph.streamVertex(T.label, "Car", "name", "Dodge" + i);
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}

Time taken: 0:00:53.787
</code></pre>

<p><img src="images/sqlg/streamingBatchModeMemory.png" alt="image of streaming batch mode memory usage" title="" />
<br />
Streaming batch mode memory usage. </p>

<p>Test executed with -Xmx128m</p>

<p>Created 10 000 000 Persons and 10 000 000 cars. <strong>No</strong> edges have been created.
<br /></p>

<p>As the <code class="language-java">Graph.streamVertex</code> method returns void there is no handle to vertex making edge creation problematic.
Precisely for this scenario there is a bulk edge creation method, <code class="language-java">SqlgGraph.bulkAddEdges(inLabel, outLabel, edgeLabel, Pair&lt;String, String&gt; idFields, List&lt;? extends Pair&lt;String, String&gt;&gt; uids)</code></p>

<ul>
<li><code class="language-java">inLabel</code> and <code class="language-java">outLabel</code> specifies the in and out vertex labels that the edges will be between.</li>
<li><code class="language-java">edgeLabel</code> is the label of the edges to be created.</li>
<li><code class="language-java">idFields</code> specifies the fields that uniquely identify the in and out vertex.</li>
<li><code class="language-java">uids</code> are the actual unique identifies for each in out vertex pairing.</li>
</ul>

<p>Sqlg will then first copy the <code class="language-java">uids</code> into a temporary table. Then it joins the temporary table on the in and out vertex tables to retrieve the in and out ids.
These ids are then inserted into the edge table. All this happens on Postgresql, having minimal processing and memory impact on the java process.</p>

<p>The unique identifiers do have to be kept in memory.</p>

<p><strong>Example illustrating streaming batch mode including bulk edges</strong></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showBulkEdgeCreation() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    int count = 0;
    for (int i = 1; i &lt;= 10; i++) {
        List&lt;Pair&lt;String, String&gt;&gt; identifiers = new ArrayList&lt;&gt;();
        this.sqlgGraph.tx().streamingBatchModeOn();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            this.sqlgGraph.streamVertex(T.label, "Person", "name", "John" + count, "personUid", String.valueOf(count));
        }
        this.sqlgGraph.tx().flush();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            this.sqlgGraph.streamVertex(T.label, "Car", "name", "Dodge" + count, "carUid", String.valueOf(count));
            identifiers.add(Pair.of(String.valueOf(count), String.valueOf(count++)));
        }
        this.sqlgGraph.tx().flush();
        this.sqlgGraph.bulkAddEdges("Person", "Car", "drives", Pair.of("personUid", "carUid"), identifiers);
        this.sqlgGraph.tx().commit();
    }
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}
Time taken: 0:04:25.502
</code></pre>

<p><img src="images/sqlg/streamBatchModeBulkEdgeMemory.png" alt="image of streaming batch mode and bulk edge creation" title="" />
<br />
Streaming with lock batch mode memory usage. </p>

<p>Test executed with -Xmx1024m</p>

<p>Created 10 000 000 Persons each with a car. i.e. 20 000 000 vertices and 10 000 000 edges.
<br /></p>

<p><br /></p>

<h3 id="StreamingwithlockbatchmodeID">Streaming with lock batch mode</h3>

<p><br /></p>

<p>Streaming with lock batch mode is similar to streaming batch mode. The difference being that the label/table being written to is
locked. Locking the table ensures that no concurrent changes will occur on the table. This allows Sqlg to query the id sequence and
assigned ids to the elements.</p>

<p>Streaming batch mode does <strong>not</strong> use the <code class="language-java">Graph.addVertex</code> method. Instead <code class="language-java">Graph.streamVertexWithLock</code> is defined.</p>

<p>The transaction must be placed into streaming with lock batch mode manually before any streaming with lock batch modification can happen. 
<code class="language-java">Graph.tx().streamingWithLockBatchModeOn()</code> After every <code class="language-java">commit()</code> or <code class="language-java">flush()</code> the transaction reverts to normal mode and must 
be placed into streaming batch mode again for streaming batch mode to continue.</p>

<p><strong>Example illustrating streaming with lock batch mode</strong></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showStreamingWithLockBatchMode() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    //enable streaming mode
    this.sqlgGraph.tx().streamingWithLockBatchModeOn();
    for (int i = 1; i &lt;= 10_000_000; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
    }
    //flushing is needed before starting streaming Car. Only only one label/table can stream at a time.
    this.sqlgGraph.tx().flush();
    for (int i = 1; i &lt;= 10_000_000; i++) {
        Vertex car = this.sqlgGraph.addVertex(T.label, "Car", "name", "Dodge" + i);
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}
Time taken: 0:00:54.139
</code></pre>

<p><img src="images/sqlg/streamingWithLockBatchModeMemory.png" alt="image of streaming with lock batch mode memory usage" title="" />
<br />
Streaming with lock batch mode memory usage </p>

<p>Test executed with -Xmx128m</p>

<p>Created 10 000 000 Persons and 10 000 000 cars. <strong>No</strong> edges were created.
<br /></p>

<p><strong>Example illustrating streaming with lock batch mode and bulk edge creation</strong></p>

<pre class="prettyprint"><code class="language-java">@Test
public void showStreamingWithLockBulkEdgeCreation() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    int count = 0;
    for (int i = 1; i &lt;= 10; i++) {
        List&lt;Vertex&gt; persons = new ArrayList&lt;&gt;();
        this.sqlgGraph.tx().streamingWithLockBatchModeOn();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + count);
            persons.add(person);
        }
        this.sqlgGraph.tx().flush();
        List&lt;Vertex&gt; cars = new ArrayList&lt;&gt;();
        for (int j = 1; j &lt;= 1_000_000; j++) {
            Vertex car = this.sqlgGraph.addVertex(T.label, "Car", "name", "Dodge" + count++);
            cars.add(car);
        }
        this.sqlgGraph.tx().flush();
        Iterator&lt;Vertex&gt; carIter = cars.iterator();
        for (Vertex person : persons) {
            person.addEdge("drives", carIter.next());
        }
        this.sqlgGraph.tx().commit();
    }
    stopWatch.stop();
    System.out.println(stopWatch.toString());
}

Time taken: 0:02:19.672
</code></pre>

<p><img src="images/sqlg/streamingWithLockBatchModeAndEdgesMemory.png" alt="image of streaming with lock batch mode memory usage" title="" />
<br />
Streaming with lock batch mode memory usage </p>

<p>Test executed with -Xmx1024m</p>

<p>Created 10 000 000 Persons each with a car. 20 000 000 vertices and 10 000 000 edges.
<br /></p>


        </div>
    </div>
    <hr>
    <footer class="pull-right">
        <p>100% open source. Licensed under the Apache Software License 2.0</p>
    </footer>

</div>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script src="javascripts/offcanvas.js"></script>
<script src="javascripts/prettify.js"></script>

<script type='text/javascript'>

    $(document).ready(function () {

        $('#sidebar').affix(
                {
                    offset: {
                        top: 40
                    }
                }
        );

        var $body = $(document.body);
        var navHeight = $('.navbar').outerHeight(true) + 10;

        $body.scrollspy({
            target: '#leftcol',
            offset: navHeight
        });

        /* smooth scrolling sections */
        $('a[href*=#]:not([href=#])').click(function () {
            if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
                var target = $(this.hash);
                target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
                if (target.length) {
                    $('html,body').animate({
                        scrollTop: target.offset().top - 50
                    }, 1000);
                    return false;
                }
            }
        });

    });

    prettyPrint();

</script>

</body>
</html>
