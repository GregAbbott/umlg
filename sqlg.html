<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="../../assets/ico/favicon.ico">

    <title>Sqlg</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- UMLG doc style -->
    <link href="stylesheets/umlg-doc.css" rel="stylesheet">

    <!-- Syntax Highlighter -->
    <link href="stylesheets/prettify.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body data-spy="scroll" data-target="#affix-nav">
<header class="navbar navbar-fixed-top navbar-inverse" role="banner">
    <div class="container">
        <div class="navbar-header">
            <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="sqlg.html" class="navbar-brand">Sqlg</a>
        </div>
        <nav class="collapse navbar-collapse" role="navigation">
            <ul class="nav navbar-nav pull-right">
                <li>
                    <a href="https://github.com/pietermartin/sqlg">Github</a>
                </li>
            </ul>
        </nav>
    </div>
</header>

<!-- Begin Body -->
<div class="container umlgcontainer">
    <div class="row">
        <div class="col-md-3" id="leftcol">
            <div class="bs-docs-sidebar hidden-print" role="complementary">
                <ul class="nav bs-docs-sidebar" id="sidebar">
                </ul>
            </div>
        </div>
        <div class="col-md-9">

            <p class="pull-right visible-xs">
                <button type="button" class="btn btn-primary btn-xs" data-toggle="offcanvas">Toggle nav</button>
            </p>
<!-- Sqlg -->

<h2>Introduction</h2>

<p><strong>Sqlg</strong> is a implementation of <a href="https://github.com/tinkerpop/tinkerpop3">TinkerPop3</a> on a <a href="http://en.wikipedia.org/wiki/Relational_database_management_system">RDBMS</a>.
Currently <a href="http://hsqldb.org/">HSQLDB</a> and <a href="http://www.postgresql.org/">Postgresql</a> are supported.</p>

<p>Sqlg has a <a href="https://groups.google.com/forum/?hl=en#!forum/sqlg">Google Group</a>.</p>

<h3>TinkerPop supported features</h3>

<p>Sqlg passes TinkerPop's <code>StructureStandardSuite</code> and <code>ProcessStandardSuite</code> test suites.</p>

<p>Graph Features <strong>not</strong> implemented.</p>

<ul>
<li>Computer</li>
<li>ThreadedTransactions</li>
<li>Variables</li>
</ul>

<p>Vertex Features <strong>not</strong> implemented.</p>

<ul>
<li>MultiProperties</li>
<li>MetaProperties</li>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>AnyIds</li>
</ul>

<p>Edge Features <strong>not</strong> implemented.</p>

<ul>
<li>UserSuppliedIds</li>
<li>NumericIds</li>
<li>AnyIds</li>
</ul>

<p>Vertex property features <strong>not</strong> implemented.</p>

<ul>
<li>UserSuppliedIds</li>
<li>AnyIds</li>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<p>Edge property feature <strong>not</strong> implemented.</p>

<ul>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<h2>Getting Started</h2>

<p><br /></p>

<h3>Maven</h3>

<p><br /></p>

<p>Maven coordinates,</p>

<p><strong>HSQLDB</strong></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-hsqldb&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-postgres&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Sqlg is designed to run as a singleton that can be shared among multiple threads. You can instantiate Sqlg using the standard
tinkerpop3 static constructors.</p>

<ul>
<li><code>SqlgGraph.open(final Configuration configuration)</code></li>
<li><code>SqlgGraph.open(final String pathToSqlgProperties)</code></li>
</ul>

<p>The configuration object requires the following properties.</p>

<p><strong>HSQLDB</strong></p>

<pre><code>jdbc.url=jdbc:hsqldb:file:/tmp/sqlg
jdbc.username=SA
jdbc.password=
</code></pre>

<p><strong>Postgresql</strong></p>

<pre><code>jdbc.url=jdbc:postgresql://localhost:5432/yourdb
jdbc.username=postgres
jdbc.password=******
</code></pre>

<p>In the case of Postgres the database must already exist.</p>

<p>If you want to run the TinkerPop tests on Postgres you need to create upfront the various databases that are used.
These are,</p>

<ul>
<li>g1</li>
<li>g2</li>
<li>readGraph</li>
<li>standard</li>
<li>subgraph</li>
<li>temp</li>
<li>temp1</li>
<li>temp2</li>
<li>prototype</li>
</ul>

<p><br /></p>

<h3>Gremlin Console</h3>

<p><br /></p>

<p><strong>HSQLDB</strong></p>

<pre><code>[pieter@pieter-laptop bin]$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin&gt; :install org.umlg sqlg-hsqldb 1.0.0.M9
==&gt;A module with the name sqlg-hsqldb is already installed
gremlin&gt; :plugin use tinkerpop.sqlg-hsqldb
==&gt;tinkerpop.sqlg-hsqldb activated
gremlin&gt; g = SqlgGraph.open('/home/pieter/Downloads/sqlg/sqlg-hsqldb/src/test/resources/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g.loadGraphML('../../data/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;2424
gremlin&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre><code>[pieter@pieter-laptop bin]$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin&gt; :install org.umlg sqlg-postgres 1.0.0.M9
==&gt;A module with the name sqlg-postgres is already installed
gremlin&gt; :plugin use tinkerpop.sqlg-postgres
==&gt;tinkerpop.sqlg-postgres activated
gremlin&gt; g = SqlgGraph.open('/home/pieter/Downloads/sqlg/sqlg-postgres/src/test/resources/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g.loadGraphML('../../data/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;2424
gremlin&gt;
</code></pre>

<p><br /></p>

<h2>Data types</h2>

<p><br /></p>

<div>
<table class="table table-striped table-bordered">
    <thead>
        <tr>
            <th>Java</th>
            <th>HSQLDB</th>
            <th>Postgres</th>
        </tr>
    </thead>
    <tbody>
        </tr>
            <td>Boolean</td>
            <td>BOOLEAN</td>
            <td>BOOLEAN</td>
        </tr>
        <tr>
            <td>Byte</td>
            <td>TINYINT</td>
            <td><strong>Not supported</strong></td>
        </tr>
        <tr>
            <td>Short</td>
            <td>SMALLINT</td>
            <td>SMALLINT</td>
        </tr>
        <tr>
            <td>Integer</td>
            <td>INTEGER</td>
            <td>INTEGER</td>
        </tr>
        <tr>
            <td>Long</td>
            <td>BIGINT</td>
            <td>BIGINT</td>
        </tr>
        <tr>
            <td>Float</td>
            <td><strong>Not supported</strong></td>
            <td>REAL</td>
        </tr>
        <tr>
            <td>Double</td>
            <td>DOUBLE</td>
            <td>DOUBLE PRECISION</td>
        </tr>
        <tr>
            <td>String</td>
            <td>LONGVARCHAR</td>
            <td>TEXT</td>
        </tr>
        <!-- Arrays -->
        <tr>
            <td>Boolean[]</td>
            <td>BOOLEAN ARRAY DEFAULT ARRAY[]</td>
            <td>BOOLEAN[]</td>
        </tr>
        <tr>
            <td>Byte[]</td>
            <td>LONGVARBINARY</td>
            <td>BYTEA</td>
        </tr>
        <tr>
            <td>Short[]</td>
            <td>SMALLINT ARRAY DEFAULT ARRAY[]</td>
            <td>SMALLINT[]</td>
        </tr>
        <tr>
            <td>Integer[]</td>
            <td>INTEGER ARRAY DEFAULT ARRAY[]</td>
            <td>INTEGER[]</td>
        </tr>
        <tr>
            <td>Long[]</td>
            <td>BIGINT ARRAY DEFAULT ARRAY[]</td>
            <td>BIGINT[]</td>
        </tr>
        <tr>
            <td>Float[]</td>
            <td>Not supported</td>
            <td>REAL[]</td>
        </tr>
        <tr>
            <td>Double[]</td>
            <td>DOUBLE ARRAY DEFAULT ARRAY[]</td>
            <td>DOUBLE PRECISION[]</td>
        </tr>
        <tr>
            <td>String[]</td>
            <td>LONGVARCHAR ARRAY DEFAULT ARRAY[]</td>
            <td>TEXT[]</td>
        </tr>
    </tbody>
</table>
</div>

<p><br /></p>

<h2>Architecture</h2>

<p><br /></p>

<p>With the coming of vertex labels to TinkerPop3 the mapping of TinkerPop's graph semantics to that of a RDBMS became natural and useful.</p>

<h3>Vertex tables</h3>

<p>Every unique vertex label maps to a table. Vertex tables are prefixed with a <code>V_</code>. i.e. <code>V_Person</code>. The vertex table
stores the vertex's properties.</p>

<h3>Edge tables</h3>

<p>Every unique edge label maps to a table. Edge tables are prefixed with a <code>E_</code>. i.e. <code>E_friend</code>. The edge table stores
each edge's adjacent vertex ids and the edge properties. The column corresponding to each adjacent vertex id (<code>IN</code> and <code>OUT</code>)
has a foreign key to the adjacent vertex's table.</p>

<p>From a rdbms' perspective each edge table is a classic <code>many to many</code> join table between vertices.</p>

<h3>TinkerPop-modern</h3>

<p>Taken from <a href="http://tinkerpop.incubator.apache.org/docs/3.0.0-SNAPSHOT/#intro">TinkerPop3</a></p>

<p><img src="images/sqlg/tinkerpop-modern-graph.png" alt="image of tinkerpop-classic" title="" /></p>

<h4>ER Diagram</h4>

<p><img src="images/sqlg/tinkerpop-modern-er.png" alt="image of tinkerpop-classic" title="" /></p>

<h4>V_person</h4>

<p><img src="images/sqlg/V_person.png" alt="image of tinkerpop-classic" title="" /></p>

<h4>V_software</h4>

<p><img src="images/sqlg/V_software.png" alt="image of tinkerpop-classic" title="" /></p>

<h4>E_knows</h4>

<p><img src="images/sqlg/E_knows.png" alt="image of tinkerpop-classic" title="" /></p>

<h4>E_created</h4>

<p><img src="images/sqlg/E_created.png" alt="image of tinkerpop-classic" title="" /></p>

<h3>Namespacing and Schemas</h3>

<p>Many RDBMS databases have the notion of a <code>schema</code> as a namespace for tables. Sqlg supports schemas
for vertex labels. Distinct schemas for edge tables are unnecessary as edge tables are created in the schema of the adjacent <code>out</code> vertex.
By default schemas for vertex tables go into the underlying databases' default schema. For postgresql and hsqldb this
is the <code>public</code> schema.</p>

<p>To specify the schema for a label Sqlg uses the dot <code>.</code> notation.</p>

<pre><code>Vertex john = this.sqlgGraph.addVertex(T.label, "manager", "name", "john");
Vertex palace1 = this.sqlgGraph.addVertex(T.label, "property.house", "name", "palace1");
Vertex corrola = this.sqlgGraph.addVertex(T.label, "fleet.car", "model", "corrola");
palace1.addEdge("managedBy", john);
corrola.addEdge("owner", john);
</code></pre>

<p>This will create a table <code>V_manager</code> in the <code>public</code> (default) schema. Table <code>V_house</code> is in a <code>property</code> schema and table <code>V_car</code>
is in a <code>fleet</code> schema. For the edges a <code>E_managedBy</code> table is created in the <code>property</code> schema and a <code>E_owner</code> table in the <code>fleet</code> schema.</p>

<p><img src="images/sqlg/schemas.png" alt="image of tinkerpop-classic" title="" /></p>

<p><br /></p>

<h2>Indexes</h2>

<p><br /></p>

<p>Sqlg supports basic indexing.</p>

<p><code>org.umlg.sqlg.structure.SqlgGraph</code> has two methods on it to create indexes one for vertices and one for edges.</p>

<ul>
<li><code>SqlgGraph.createVertexLabeledIndex(String label, Object... dummykeyValues)</code></li>
<li><code>SqlgGraph.createEdgeLabeledIndex(String label, Object... dummykeyValues)</code></li>
</ul>

<p>The <code>dummykeyValues</code> are required to indicate to Sqlg the name and type of the property. The type is needed when
the column does not yet exist and Sqlg needs to create it.</p>

<p>Outside of creating the index Sqlg has no further direct interaction with index logic. However gremlin queries with a
<code>has</code> step will translate to a <code>sql</code> <code>where</code> clause. If an index has been created on the property of the <code>has</code> step then
the underlying sql engine will utilize that index.</p>

<h3>Example</h3>

<pre><code>@Test
public void testIndexOnVertex() throws SQLException {
    this.sqlgGraph.createVertexLabeledIndex("Person", "name", "dummy");
    this.sqlgGraph.tx().commit();
    for (int i = 0; i &lt; 5000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "john" + i);
    }
    this.sqlgGraph.tx().commit();
    assertEquals(1, this.sqlgGraph.V().has(T.label, "Person").has("name", "john50").count().next(), 0);

    //Check if the index is being used
    Connection conn = this.sqlgGraph.tx().getConnection();
    Statement statement = conn.createStatement();
    ResultSet rs = statement.executeQuery("explain analyze SELECT * FROM \"public\".\"V_Person\" a WHERE a.\"name\" = 'john50'");
    assertTrue(rs.next());
    String result = rs.getString(1);
    System.out.println(result);
    assertTrue(result.contains("Index Scan") || result.contains("Bitmap Heap Scan"));
    statement.close();
    this.sqlgGraph.tx().rollback();
}

Output: "Bitmap Heap Scan on "V_Person" a  (cost=4.42..32.42 rows=18 width=40) (actual time=0.016..0.016 rows=1 loops=1)"
</code></pre>

<p>In the above example, Sqlg will create a table <code>V_Person</code> with column <code>name</code> together with an index on the <code>name</code>.
At present the default index is created. For postgresql this is a <code>Btree</code> index.</p>

<p>The output shows the result of a postgres query explain plan. The result shows that postgres does indeed utilize the index.</p>

<p>The gremlin query <code>this.sqlgGraph.V().has(T.label, "Person").has("name1", "john50")</code> will utilize the index on the <code>name</code> field.
Currently only <code>Compare.eq</code> is supported.</p>

<p><br /></p>

<h2>Schema creation</h2>

<p><br /></p>

<p>Sqlg creates the schema lazily. This is great, but comes with serious caveats.</p>

<p><strong>HSQLDB</strong> does not support transactional schema creation. HSQLDB automatically commits any schema creation/alter command
and immediately starts a new transaction.
This can have some rather unfortunate consequences, as HSQLDB will silently commit a user transaction thus invalidating
the user's transaction semantics.</p>

<p><strong>Postgres</strong> supports transactional schema creation/alter commands. The user's transaction semantics remain intact.
 However schema creation commands creates table level locks which increases the risk of deadlocks in a multi-threaded environment.</p>

<p><br /></p>

<h2>Sql queries</h2>

<p><br /></p>

<p><strong>Note</strong> Experimental Feature</p>

<pre><code>List&lt;Vertex&gt; SqlgGraph.vertexQuery(String sql)
</code></pre>

<p>The requirement is that the given sql must return a <code>ID</code> column representing any vertex idx.
Sqlg will then be able to wrap the given sql to retrieve the necessary data to instantiate a SqlgVertex. This way only one
sql query is executed to retrieve vertices. The performance impact on the original query should be minimal.</p>

<p><br /></p>

<h2>Multiple Jvm</h2>

<p><br /></p>

<p>It is possible to run many Sqlg instances pointing to the same underlying database. These instances can be in the same jvm
but is primarily intended for separate jvm(s) pointing to the same underlying database.</p>

<p>Sqlg caches database schema information. When multiple Sqlg instances point to the same database,
Sqlg uses <a href="http://hazelcast.com/">Hazelcast</a> as a distributed cache of the schema information.</p>

<p>To indicate to Sqlg that a <code>Hazelcast</code> cluster is required  you must specify <code>hazelcast.members=ipaddres1,ipaddres2,ipaddres3</code>
in the constructors configuration object. Hazelcast will then automatically set up the distributed cluster for the schema
information.</p>

<p><br /></p>

<h2>Batch mode</h2>

<p><br /></p>

<p>Postgres is significantly slower than HSQLDB. This is expected as Postgres runs as a server. HSQLDB shines when it runs
in embedded mode. (HSQLDB has not been tested in server mode!)</p>

<p>Sqlg supports a batch mode. This is currently only implemented on Postgres.
Batch mode is activated on the transaction object itself. After every <code>commit</code> batchMode needs to be reactivated.</p>

<pre><code>@Test
public void testBatchMode() {
    this.sqlgGraph.tx().batchModeOn();
    for (int i = 0; i &lt; 1000000; i++) {
        Vertex person1 = this.sqlgGraph.addVertex(T.label, "Person", "name", "a" + i);
        Vertex person2 = this.sqlgGraph.addVertex(T.label, "Person", "name", "b" + i);
        person1.addEdge("friend", person2, "context", 1);
        if (i != 0 &amp;&amp; i % 100000 == 0) {
            this.sqlgGraph.tx().commit();
            this.sqlgGraph.tx().batchModeOn();
        }
    }
    this.sqlgGraph.tx().commit();
}
</code></pre>

<p>With <code>batchMode</code> on Sqlg will cache all modifications to the graph and on <code>commit</code> execute bulk sql statements.
This causes a very significant improvement of performance.</p>

<p><br /></p>

<h2>Performance Indicator</h2>

<p><br /></p>

<p>Below are some fairly trivial examples using Sqlg, the purpose of which is to give an indication of the performance that can be
expected from Sqlg.</p>

<p>All tests were run on a standard laptop with the following specs.</p>

<ul>
<li>Intel(R) Core(TM) i7-4800MQ CPU @ 2.70GHz</li>
<li>500G Solid state drive</li>
</ul>

<p>Running TinkerPop's <code>StructurePerformanceTest</code> produces the following output</p>

<p><strong>HSQLDB</strong></p>

<pre><code>WriteToIO.writeGraphSON: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 1.42 [+- 1.82]...
WriteToIO.writeKryo: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 0.70 [+- 0.11]...
WriteToIO.writeGraphML: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 0.77 [+- 0.06]...
WriteToGraph.writeEmptyVertices: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.31 [+- 0.43]...
WriteToGraph.writeEmptyVerticesAndEdges: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 11.52 [+- 0.63]...
ReadFromGraph.readAllProperties: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 4.26 [+- 0.97]...
</code></pre>

<p><strong>Postgres</strong></p>

<pre><code>WriteToIO.writeGraphSON: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.62 [+- 0.46]...
WriteToIO.writeKryo: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.64 [+- 0.11]...
WriteToIO.writeGraphML: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 4.24 [+- 0.10]...
WriteToGraph.writeEmptyVertices: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 14.53 [+- 0.19]...
WriteToGraph.writeEmptyVerticesAndEdges: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 48.64 [+- 0.41]...
ReadFromGraph.readAllProperties: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 16.00 [+- 0.35]...
</code></pre>

<h3>Some trivial examples.</h3>

<h4>Create 10000 objects, each with 2 properties</h4>

<pre><code>@Test
public void testAddPersons() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 0; i &lt; 10000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "prop1", "property1", "prop2", "property2");
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();
    Assert.assertEquals(Long.valueOf(10000), this.sqlgGraph.V().has(T.label, "Person").count().next());
    stopWatch.stop();
    System.out.println("Time to read: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre><code>Time to insert: 0:00:00.672
Time to read: 0:00:00.124
</code></pre>

<p><strong>Postgres</strong></p>

<pre><code>Time to insert: 0:00:01.955
Time to read: 0:00:00.117
</code></pre>

<p>Note that the Postgres read time is roughly equivalent to that of HSQLDB. This is because in the above test there is only one call to
the database. Postgres itself is fast, however round trips between client and server are expensive.</p>

<h4>Create 10001 Persons, each with 2 properties and one friend</h4>

<pre><code>@Test
public void testAddPersonAndFriends() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    Vertex previous = this.sqlgGraph.addVertex(T.label, "Person", "name", "first");

    for (int i = 0; i &lt; 10000; i++) {
        Vertex current = this.sqlgGraph.addVertex(T.label, "Person", "name", "current" + i);
        previous.addEdge("friend", current);
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();
    List&lt;Vertex&gt; persons = this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").toList();
    Map&lt;Vertex, List&lt;Vertex&gt;&gt; friendMap = new HashMap&lt;&gt;();
    persons.forEach(
            p -&gt; friendMap.put(p, p.in("friend").toList())
    );
    Assert.assertEquals(10001, friendMap.size());
    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre><code>Time to insert: 0:00:02.095
Time to read all vertices: 0:00:01.138
</code></pre>

<p><strong>Postgres</strong></p>

<pre><code>Time to insert: 0:00:04.810
Time to read all vertices: 0:00:09.177
</code></pre>

<p>To retrieve the friends 1001 calls are made made. Postgres is significantly slower in this case.</p>

<h4>Postgres, Create 1 000 000 Persons and Dogs with a pet edge. BatchMode on.</h4>

<pre><code>@Test
public void testPostgresBatchMode() {
    this.sqlgGraph.tx().batchModeOn();
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 1; i &lt; 1000001; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex dog = this.sqlgGraph.addVertex(T.label, "Dog", "name", "snowy" + i);
        person.addEdge("pet", dog);
        if (1 % 100000 == 0) {
            this.sqlgGraph.tx().commit();
            this.sqlgGraph.tx().batchModeOn();
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();

    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").count().next().intValue());
    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Dog").count().next().intValue());

    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>Postgres</strong></p>

<pre><code>Time to insert: 0:00:51.681
Time to read all vertices: 0:00:16.130
</code></pre>

<h4>HSQLDB, Create 1 000 000 Persons and Dogs with a pet edge.</h4>

<pre><code>@Test
public void testHsqldbLargeLoad() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 1; i &lt; 1000001; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex dog = this.sqlgGraph.addVertex(T.label, "Dog", "name", "snowy" + i);
        person.addEdge("pet", dog);
        if (i % 100000 == 0) {
            this.sqlgGraph.tx().commit();
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();

    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").count().next().intValue());
    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Dog").count().next().intValue());

    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre><code>Time to insert: 0:02:32.435
Time to read all vertices: 0:00:19.026
</code></pre>

        </div>
    </div>
    <hr>
    <footer class="pull-right">
        <p>100% open source. Licensed under the Apache Software License 2.0</p>
    </footer>

</div>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script src="javascripts/offcanvas.js"></script>
<script src="javascripts/prettify.js"></script>

<script type='text/javascript'>

    $(document).ready(function () {

        $('#sidebar').affix(
                {
                    offset: {
                        top: 40
                    }
                }
        );

        var $body = $(document.body);
        var navHeight = $('.navbar').outerHeight(true) + 10;

        $body.scrollspy({
            target: '#leftcol',
            offset: navHeight
        });

        /* smooth scrolling sections */
        $('a[href*=#]:not([href=#])').click(function () {
            if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
                var target = $(this.hash);
                target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
                if (target.length) {
                    $('html,body').animate({
                        scrollTop: target.offset().top - 50
                    }, 1000);
                    return false;
                }
            }
        });

    });

    prettyPrint();

</script>

</body>
</html>
