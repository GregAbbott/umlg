<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="../../assets/ico/favicon.ico">

    <title>Sqlg</title>

    <!-- Bootstrap core CSS -->
    <link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- UMLG doc style -->
    <link href="stylesheets/umlg-doc.css" rel="stylesheet">

    <!-- Syntax Highlighter -->
    <link href="stylesheets/prettify.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body data-spy="scroll" data-target="#affix-nav">
<header class="navbar navbar-fixed-top navbar-inverse" role="banner">
    <div class="container">
        <div class="navbar-header">
            <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="sqlg.html" class="navbar-brand">Sqlg</a>
        </div>
        <nav class="collapse navbar-collapse" role="navigation">
            <ul class="nav navbar-nav pull-right">
                <li>
                    <a href="https://github.com/pietermartin/sqlg">Github</a>
                </li>
            </ul>
        </nav>
    </div>
</header>

<!-- Begin Body -->
<div class="container umlgcontainer">
    <div class="row">
        <div class="col-md-3" id="leftcol">
            <div class="bs-docs-sidebar hidden-print" role="complementary">
                <ul class="nav bs-docs-sidebar" id="sidebar">
                    <li class="active"><a href="#IntroductionID">Introduction</a><ul class="nav">
<li><a href="#TinkerpopsupportedfeaturesID">Tinkerpop supported features</a></li></ul>
</li><li><a href="#GettingStartedID">Getting Started</a><ul class="nav">
<li><a href="#MavenID">Maven</a></li><li><a href="#GremlinConsoleID">Gremlin Console</a></li></ul>
</li><li><a href="#DatatypesID">Data types</a></li><li><a href="#ArchitectureID">Architecture</a><ul class="nav">
<li><a href="#VertextablesID">Vertex tables</a></li><li><a href="#EdgetablesID">Edge tables</a></li><li><a href="#VERTICESandEDGESID">VERTICES and EDGES</a><ul class="nav">
<li><a href="#VERTICESID">VERTICES</a></li><li><a href="#EDGESID">EDGES</a></li></ul>
</li><li><a href="#Tinkerpop-classicID">Tinkerpop-classic</a><ul class="nav">
<li><a href="#ERDiagramID">ER Diagram</a></li><li><a href="#AlltablesID">All tables</a></li><li><a href="#V_personID">V_person</a></li><li><a href="#V_softwareID">V_software</a></li><li><a href="#E_knowsID">E_knows</a></li><li><a href="#E_createdID">E_created</a></li><li><a href="#VERTICESID">VERTICES</a></li><li><a href="#EDGESID">EDGES</a></li></ul>
</li><li><a href="#NamespacingandSchemasID">Namespacing and Schemas</a></li></ul>
</li><li><a href="#IndexesID">Indexes</a><ul class="nav">
<li><a href="#ExampleID">Example</a></li></ul>
</li><li><a href="#SchemacreationID">Schema creation</a></li><li><a href="#SqlqueriesID">Sql queries</a></li><li><a href="#MultipleJvmID">Multiple Jvm</a></li><li><a href="#BatchmodeID">Batch mode</a></li><li><a href="#PerformanceIndicatorID">Performance Indicator</a><ul class="nav">
<li><a href="#Sometrivialexamples.ID">Some trivial examples.</a><ul class="nav">
<li><a href="#Create10000objects,eachwith2propertiesID">Create 10000 objects, each with 2 properties</a></li><li><a href="#Create10001Persons,eachwith2propertiesandonefriendID">Create 10001 Persons, each with 2 properties and one friend</a></li><li><a href="#Postgres,Create1000000PersonsandDogswithapetedge.BatchModeon.ID">Postgres, Create 1 000 000 Persons and Dogs with a pet edge. BatchMode on.</a></li><li><a href="#HSQLDB,Create1000000PersonsandDogswithapetedge.ID">HSQLDB, Create 1 000 000 Persons and Dogs with a pet edge.</a></li></ul>
</li></ul>
</li>
                </ul>
            </div>
        </div>
        <div class="col-md-9">

            <p class="pull-right visible-xs">
                <button type="button" class="btn btn-primary btn-xs" data-toggle="offcanvas">Toggle nav</button>
            </p>
            <!-- Sqlg -->

<h2 id="IntroductionID">Introduction</h2>

<p><strong>Sqlg</strong> is a implementation of <a href="https://github.com/tinkerpop/tinkerpop3">Tinkerpop3</a> on a <a href="http://en.wikipedia.org/wiki/Relational_database_management_system">RDBMS</a>.
Currently <a href="http://hsqldb.org/">HSQLDB</a> and <a href="http://www.postgresql.org/">Postgresql</a> are supported.</p>

<h3 id="TinkerpopsupportedfeaturesID">Tinkerpop supported features</h3>

<p>Sqlg passes Tinkerpop's <code class="language-java">StructureStandardSuite</code> and <code class="language-java">ProcessStandardSuite</code> test suites.</p>

<p>Graph Features <strong>not</strong> implemented.</p>

<ul>
<li>Computer</li>
<li>ThreadedTransactions</li>
<li>Variables</li>
</ul>

<p>Vertex Features <strong>not</strong> implemented.</p>

<ul>
<li>MultiProperties</li>
<li>MetaProperties</li>
<li>UserSuppliedIds</li>
</ul>

<p>Edge Features <strong>not</strong> implemented.</p>

<ul>
<li>UserSuppliedIds</li>
</ul>

<p>Vertex property features <strong>not</strong> implemented.</p>

<ul>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<p>Edge property feature <strong>not</strong> implemented.</p>

<ul>
<li>MapValues</li>
<li>MixedListValues</li>
<li>SerializableValues</li>
<li>UniformListValues</li>
</ul>

<h2 id="GettingStartedID">Getting Started</h2>

<p><br /></p>

<h3 id="MavenID">Maven</h3>

<p><br /></p>

<p>Maven coordinates,</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-hsqldb&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.M1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.umlg&lt;/groupId&gt;
    &lt;artifactId&gt;sqlg-postgres&lt;/artifactId&gt;
    &lt;version&gt;1.0.0.M1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>Sqlg is designed to run as a singleton that can be shared among multiple threads. You can instantiate Sqlg using the standard
tinkerpop3 static constructors.</p>

<ul>
<li><code class="language-java">SqlgGraph.open(final Configuration configuration)</code></li>
<li><code class="language-java">SqlgGraph.open(final String pathToSqlgProperties)</code></li>
</ul>

<p>The configuration object requires the following properties.</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:hsqldb:file:/tmp/sqlg
jdbc.username=SA
jdbc.password=
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">jdbc.url=jdbc:postgresql://localhost:5432/sqlgraphdb
jdbc.username=postgres
jdbc.password=******
</code></pre>

<p>In the case of Postgres the database must already exist.</p>

<p>If you want to run the Tinkerpop tests on Postgres you need to create upfront the various databases that are used.
These are,</p>

<ul>
<li>g1</li>
<li>g2</li>
<li>readGraph</li>
<li>standard</li>
<li>subgraph</li>
<li>temp</li>
<li>temp1</li>
<li>temp2</li>
</ul>

<p><br /></p>

<h3 id="GremlinConsoleID">Gremlin Console</h3>

<p><br /></p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">[pieter@pieter-laptop bin]$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin&gt; :install org.umlg sqlg-hsqldb 1.0.0.M1
==&gt;A module with the name sqlg-hsqldb is already installed
gremlin&gt; :plugin use tinkerpop.sqlg-hsqldb
==&gt;tinkerpop.sqlg-hsqldb activated
gremlin&gt; g = SqlgGraph.open('/home/pieter/Downloads/sqlg/sqlg-hsqldb/src/test/resources/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g.loadGraphML('../../data/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;2424
gremlin&gt;
</code></pre>

<p><strong>Postgresql</strong></p>

<pre class="prettyprint"><code class="language-java">[pieter@pieter-laptop bin]$ ./gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin&gt; :install org.umlg sqlg-postgres 0.0.2-SNAPSHOT
==&gt;A module with the name sqlg-postgres is already installed
gremlin&gt; :plugin use tinkerpop.sqlg-postgres
==&gt;tinkerpop.sqlg-postgres activated
gremlin&gt; g = SqlgGraph.open('/home/pieter/Downloads/sqlg/sqlg-postgres/src/test/resources/sqlg.properties')
==&gt;sqlggraph[SqlGraph]
gremlin&gt; g.loadGraphML('../../data/grateful-dead.xml')
==&gt;null
gremlin&gt; g.V().count()
==&gt;2424
gremlin&gt;
</code></pre>

<p><br /></p>

<h2 id="DatatypesID">Data types</h2>

<p><br /></p>

<div>
<table class="table table-striped table-bordered">
    <thead>
        <tr>
            <th>Java</th>
            <th>HSQLDB</th>
            <th>Postgres</th>
        </tr>
    </thead>
    <tbody>
        </tr>
            <td>Boolean</td>
            <td>BOOLEAN</td>
            <td>BOOLEAN</td>
        </tr>
        <tr>
            <td>Byte</td>
            <td>TINYINT</td>
            <td><strong>Not supported</strong></td>
        </tr>
        <tr>
            <td>Short</td>
            <td>SMALLINT</td>
            <td>SMALLINT</td>
        </tr>
        <tr>
            <td>Integer</td>
            <td>INTEGER</td>
            <td>INTEGER</td>
        </tr>
        <tr>
            <td>Long</td>
            <td>BIGINT</td>
            <td>BIGINTtd>
        </tr>
        <tr>
            <td>Float</td>
            <td><strong>Not supported</strong></td>
            <td>REAL</td>
        </tr>
        <tr>
            <td>Double</td>
            <td>DOUBLE</td>
            <td>DOUBLE PRECISION</td>
        </tr>
        <tr>
            <td>String</td>
            <td>LONGVARCHAR</td>
            <td>TEXT</td>
        </tr>
        <!-- Arrays -->
        <tr>
            <td>Boolean[]</td>
            <td>BOOLEAN ARRAY DEFAULT ARRAY[]</td>
            <td>BOOLEAN[]</td>
        </tr>
        <tr>
            <td>Byte[]</td>
            <td>LONGVARBINARY</td>
            <td>BYTEA</td>
        </tr>
        <tr>
            <td>Short[]</td>
            <td>SMALLINT ARRAY DEFAULT ARRAY[]</td>
            <td>SMALLINT[]</td>
        </tr>
        <tr>
            <td>Integer[]</td>
            <td>INTEGER ARRAY DEFAULT ARRAY[]</td>
            <td>INTEGER[]</td>
        </tr>
        <tr>
            <td>Long[]</td>
            <td>BIGINT ARRAY DEFAULT ARRAY[]</td>
            <td>BIGINT[]</td>
        </tr>
        <tr>
            <td>Float[]</td>
            <td>Not supported</td>
            <td>REAL[]</td>
        </tr>
        <tr>
            <td>Double[]</td>
            <td>DOUBLE ARRAY DEFAULT ARRAY[]</td>
            <td>DOUBLE PRECISION[]</td>
        </tr>
        <tr>
            <td>String[]</td>
            <td>LONGVARCHAR ARRAY DEFAULT ARRAY[]</td>
            <td>TEXT[]</td>
        </tr>
    </tbody>
</table>
</div>

<p><br /></p>

<h2 id="ArchitectureID">Architecture</h2>

<p><br /></p>

<p>With the coming of vertex labels to Tinkerpop3 the mapping of Tinkerpop's graph semantics to that of a RDBMS became natural and useful.</p>

<h3 id="VertextablesID">Vertex tables</h3>

<p>Every unique vertex label maps to a table. Vertex tables are prefixed with a <code class="language-java">V_</code>. i.e. <code class="language-java">V_Person</code>. The vertex table
stores the vertex's properties.</p>

<h3 id="EdgetablesID">Edge tables</h3>

<p>Every unique edge label maps to a table. Edge tables are prefixed with a <code class="language-java">E_</code>. i.e. <code class="language-java">E_friend</code>. The edge table stores
each edge's adjacent vertex ids and the edge properties. The column corresponding to each adjacent vertex id (<code class="language-java">IN</code> and <code class="language-java">OUT</code>)
has a foreign key to the adjacent vertex's table.</p>

<h3 id="VERTICESandEDGESID">VERTICES and EDGES</h3>

<p>There are two special tables in Sqlg. One is for vertices (<code class="language-java">VERTICES</code>) and the other is for edges (<code class="language-java">EDGES</code>).</p>

<h4 id="VERTICESID">VERTICES</h4>

<p>The <code class="language-java">VERTICES</code> table has one record for every vertex in the graph. The <code class="language-java">VERTICES</code> table's auto generated primary key
functions as the vertex id. Additionally the <code class="language-java">VERTICES</code> table stores each vertex's label and the unique set of labels of
each vertex's incident edges.</p>

<p>Every vertex has a label and as such a vertex table. This table's <code class="language-java">ID</code> column has a one to one mapping the <code class="language-java">ID</code> column
of the <code class="language-java">VERTICES</code> table.</p>

<p>This strategy allows gremlin queries of the form <code class="language-java">g.V(1L)</code> to find a specific vertex in the <code class="language-java">VERTICES</code> table and then know in which
table the vertex is stored.</p>

<p>For example, a query of the form <code class="language-java">g.V().has(T.label, 'Person')</code> will go directly to the <code class="language-java">V_Person</code>.</p>

<h4 id="EDGESID">EDGES</h4>

<p>The <code class="language-java">EDGES</code> table has one record for every edge in the graph. The <code class="language-java">EDGES</code> tables' auto generated primary key
functions as the edge id. Additionally the <code class="language-java">EDGES</code> table stores each edge's label.</p>

<p>Similar to the vertex look-ups the <code class="language-java">EDGES</code> table facilitates implementing queries of the form <code class="language-java">g.E(1L)</code></p>

<h3 id="Tinkerpop-classicID">Tinkerpop-classic</h3>

<p>Taken from <a href="http://www.tinkerpop.com/docs/3.0.0-SNAPSHOT/#intro">Tinkerpop3</a></p>

<p><img src="images/sqlg/tinkerpop-classic-graph.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="ERDiagramID">ER Diagram</h4>

<p><img src="images/sqlg/tinkerpop-classic1-er.png" alt="image of tinkerpop-classic" title="" />
<img src="images/sqlg/tinkerpop-classic2-er.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="AlltablesID">All tables</h4>

<p><img src="images/sqlg/tinkerpop-classic.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="V_personID">V_person</h4>

<p><img src="images/sqlg/person.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="V_softwareID">V_software</h4>

<p><img src="images/sqlg/software.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="E_knowsID">E_knows</h4>

<p><img src="images/sqlg/knows.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="E_createdID">E_created</h4>

<p><img src="images/sqlg/created.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="VERTICESID">VERTICES</h4>

<p><img src="images/sqlg/vertices.png" alt="image of tinkerpop-classic" title="" /></p>

<h4 id="EDGESID">EDGES</h4>

<p><img src="images/sqlg/edges.png" alt="image of tinkerpop-classic" title="" /></p>

<h3 id="NamespacingandSchemasID">Namespacing and Schemas</h3>

<p>Many RDBMS databases have the notion of a <code class="language-java">schema</code> as a namespace for tables. Sqlg supports schemas
for vertex labels. Distinct schemas for edge tables are unnecessary as edge tables are created in the schema of the adjacent <code class="language-java">out</code> vertex.
By default schemas for vertex tables go into the underlying databases' default schema. For postgresql and hsqldb this
is the <code class="language-java">public</code> schema.</p>

<p>To specify the schema for a label Sqlg uses the dot <code class="language-java">.</code> notation.</p>

<pre class="prettyprint"><code class="language-java">Vertex john = this.sqlgGraph.addVertex(T.label, "manager", "name", "john");
Vertex palace1 = this.sqlgGraph.addVertex(T.label, "property.house", "name", "palace1");
Vertex corrola = this.sqlgGraph.addVertex(T.label, "fleet.car", "model", "corrola");
palace1.addEdge("managedBy", john);
corrola.addEdge("owner", john);
</code></pre>

<p>This will create a table <code class="language-java">V_manager</code> in the <code class="language-java">public</code> (default) schema. Table <code class="language-java">V_house</code> is in a <code class="language-java">property</code> schema and table <code class="language-java">V_car</code>
is in a <code class="language-java">fleet</code> schema. For the edges a <code class="language-java">E_managedBy</code> table is created in the <code class="language-java">property</code> schema and a <code class="language-java">E_owner</code> table in the <code class="language-java">fleet</code> schema.</p>

<p><img src="images/sqlg/schemas.png" alt="image of tinkerpop-classic" title="" /></p>

<p><br /></p>

<h2 id="IndexesID">Indexes</h2>

<p><br /></p>

<p>Sqlg supports basic indexing.</p>

<p><code class="language-java">org.umlg.sqlg.structure.SqlgGraph</code> has two methods on it to create indexes one for vertices and one for edges.</p>

<ul>
<li><code class="language-java">SqlgGraph.createVertexLabeledIndex(String label, Object... dummykeyValues)</code></li>
<li><code class="language-java">SqlgGraph.createEdgeLabeledIndex(String label, Object... dummykeyValues)</code></li>
</ul>

<p>The <code class="language-java">dummykeyValues</code> are required to indicate to Sqlg the name and type of the property. The type is needed when
the column does not yet exist and Sqlg needs to create it.</p>

<p>Outside of creating the index Sqlg has no further direct interaction with index logic. However gremlin queries with a
<code class="language-java">has</code> step will translate to a <code class="language-java">sql</code> <code class="language-java">where</code> clause. If an index has been created on the property of the <code class="language-java">has</code> step then
the underlying sql engine will utilize that index.</p>

<h3 id="ExampleID">Example</h3>

<pre class="prettyprint"><code class="language-java">@Test
public void testIndexOnVertex() throws SQLException {
    this.sqlgGraph.createVertexLabeledIndex("Person", "name", "dummy");
    this.sqlgGraph.tx().commit();
    for (int i = 0; i &lt; 5000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "name", "john" + i);
    }
    this.sqlgGraph.tx().commit();
    assertEquals(1, this.sqlgGraph.V().has(T.label, "Person").has("name", "john50").count().next(), 0);

    //Check if the index is being used
    Connection conn = this.sqlgGraph.tx().getConnection();
    Statement statement = conn.createStatement();
    ResultSet rs = statement.executeQuery("explain analyze SELECT * FROM \"public\".\"V_Person\" a WHERE a.\"name\" = 'john50'");
    assertTrue(rs.next());
    String result = rs.getString(1);
    System.out.println(result);
    assertTrue(result.contains("Index Scan") || result.contains("Bitmap Heap Scan"));
    statement.close();
    this.sqlgGraph.tx().rollback();
}

Output: "Bitmap Heap Scan on "V_Person" a  (cost=4.42..32.42 rows=18 width=40) (actual time=0.016..0.016 rows=1 loops=1)"
</code></pre>

<p>In the above example, Sqlg will create a table <code class="language-java">V_Person</code> with column <code class="language-java">name</code> together with an index on the <code class="language-java">name</code>.
At present the default index is created. For postgresql this is a <code class="language-java">Btree</code> index.</p>

<p>The output shows the result of a postgres query explain plan. The result shows that postgres does indeed utilize the index.</p>

<p>The gremlin query <code class="language-java">this.sqlgGraph.V().has(T.label, "Person").has("name1", "john50")</code> will utilize the index on the <code class="language-java">name</code> field.
Currently only <code class="language-java">Compare.eq</code> is supported.</p>

<p><br /></p>

<h2 id="SchemacreationID">Schema creation</h2>

<p><br /></p>

<p>Sqlg creates the schema lazily. This is great, but comes with serious caveats.</p>

<p><strong>HSQLDB</strong> does not support transactional schema creation. HSQLDB automatically commits any schema creation/alter command
and immediately starts a new transaction.
This can have some rather unfortunate consequences, as HSQLDB will silently commit a user transaction thus invalidating
the user's transaction semantics.</p>

<p><strong>Postgres</strong> supports transactional schema creation/alter commands. The user's transaction semantics remain intact.
 However schema creation commands creates table level locks which increases the risk of deadlocks in a multi-threaded environment.</p>

<p><br /></p>

<h2 id="SqlqueriesID">Sql queries</h2>

<p><br /></p>

<p><strong>Note</strong> Experimental Feature</p>

<pre class="prettyprint"><code class="language-java">List&lt;Vertex&gt; SqlgGraph.vertexQuery(String sql)
</code></pre>

<p>The requirement is that the given sql must return a <code class="language-java">ID</code> column representing any vertex idx.
Sqlg will then be able to wrap the given sql to retrieve the necessary data to instantiate a SqlgVertex. This way only one
sql query is executed to retrieve vertices. The performance impact on the original query should be minimal.</p>

<p><br /></p>

<h2 id="MultipleJvmID">Multiple Jvm</h2>

<p><br /></p>

<p>It is possible to run many Sqlg instances pointing to the same underlying database. These instances can be in the same jvm
but is primarily intended for separate jvm(s) pointing to the same underlying database.</p>

<p>Sqlg caches database schema information. When multiple Sqlg instances point to the same database,
Sqlg uses <a href="http://hazelcast.com/">Hazelcast</a> as a distributed cache of the schema information.</p>

<p>To indicate to Sqlg that a <code class="language-java">Hazelcast</code> cluster is required  you must specify <code class="language-java">hazelcast.members=ipaddres1,ipaddres2,ipaddres3</code>
in the constructors configuration object. Hazelcast will then automatically set up the distributed cluster for the schema
information.</p>

<p><br /></p>

<h2 id="BatchmodeID">Batch mode</h2>

<p><br /></p>

<p>Postgres is significantly slower than HSQLDB. This is expected as Postgres runs as a server. HSQLDB shines when it runs
in embedded mode. (HSQLDB has not been tested in server mode!)</p>

<p>Sqlg supports a batch mode. This is currently only implemented on Postgres.
Batch mode is activated on the transaction object itself. After every <code class="language-java">commit</code> batchMode needs to be reactivated.</p>

<pre class="prettyprint"><code class="language-java">@Test
public void testBatchMode() {
    this.sqlgGraph.tx().batchModeOn();
    for (int i = 0; i &lt; 1000000; i++) {
        Vertex person1 = this.sqlgGraph.addVertex(T.label, "Person", "name", "a" + i);
        Vertex person2 = this.sqlgGraph.addVertex(T.label, "Person", "name", "b" + i);
        person1.addEdge("friend", person2, "context", 1);
        if (i != 0 &amp;&amp; i % 100000 == 0) {
            this.sqlgGraph.tx().commit();
            this.sqlgGraph.tx().batchModeOn();
        }
    }
    this.sqlgGraph.tx().commit();
}
</code></pre>

<p>With <code class="language-java">batchMode</code> on Sqlg will cache all modifications to the graph and on <code class="language-java">commit</code> execute bulk sql statements.
This causes a very significant improvement of performance.</p>

<p><br /></p>

<h2 id="PerformanceIndicatorID">Performance Indicator</h2>

<p><br /></p>

<p>Below are some fairly trivial examples using Sqlg, the purpose of which is to give an indication of the performance that can be
expected from Sqlg.</p>

<p>All tests were run on a standard laptop with the following specs.</p>

<ul>
<li>Intel(R) Core(TM) i7-4800MQ CPU @ 2.70GHz</li>
<li>500G Solid state drive</li>
</ul>

<p>Running Tinkerpop's <code class="language-java">StructurePerformanceTest</code> produces the following output</p>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">WriteToIO.writeGraphSON: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 1.42 [+- 1.82]...
WriteToIO.writeKryo: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 0.70 [+- 0.11]...
WriteToIO.writeGraphML: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 0.77 [+- 0.06]...
WriteToGraph.writeEmptyVertices: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.31 [+- 0.43]...
WriteToGraph.writeEmptyVerticesAndEdges: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 11.52 [+- 0.63]...
ReadFromGraph.readAllProperties: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 4.26 [+- 0.97]...
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">WriteToIO.writeGraphSON: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.62 [+- 0.46]...
WriteToIO.writeKryo: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 3.64 [+- 0.11]...
WriteToIO.writeGraphML: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 4.24 [+- 0.10]...
WriteToGraph.writeEmptyVertices: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 14.53 [+- 0.19]...
WriteToGraph.writeEmptyVerticesAndEdges: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 48.64 [+- 0.41]...
ReadFromGraph.readAllProperties: [measured 10 out of 10 rounds, threads: 1 (sequential)]
 round: 16.00 [+- 0.35]...
</code></pre>

<h3 id="Sometrivialexamples.ID">Some trivial examples.</h3>

<h4 id="Create10000objects,eachwith2propertiesID">Create 10000 objects, each with 2 properties</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testAddPersons() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 0; i &lt; 10000; i++) {
        this.sqlgGraph.addVertex(T.label, "Person", "prop1", "property1", "prop2", "property2");
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();
    Assert.assertEquals(Long.valueOf(10000), this.sqlgGraph.V().has(T.label, "Person").count().next());
    stopWatch.stop();
    System.out.println("Time to read: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:00.672
Time to read: 0:00:00.124
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:01.955
Time to read: 0:00:00.117
</code></pre>

<p>Note that the Postgres read time is roughly equivalent to that of HSQLDB. This is because in the above test there is only one call to
the database. Postgres itself is fast, however round trips between client and server are expensive.</p>

<h4 id="Create10001Persons,eachwith2propertiesandonefriendID">Create 10001 Persons, each with 2 properties and one friend</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testAddPersonAndFriends() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    Vertex previous = this.sqlgGraph.addVertex(T.label, "Person", "name", "first");

    for (int i = 0; i &lt; 10000; i++) {
        Vertex current = this.sqlgGraph.addVertex(T.label, "Person", "name", "current" + i);
        previous.addEdge("friend", current);
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();
    List&lt;Vertex&gt; persons = this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").toList();
    Map&lt;Vertex, List&lt;Vertex&gt;&gt; friendMap = new HashMap&lt;&gt;();
    persons.forEach(
            p -&gt; friendMap.put(p, p.in("friend").toList())
    );
    Assert.assertEquals(10001, friendMap.size());
    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:02.095
Time to read all vertices: 0:00:01.138
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:04.810
Time to read all vertices: 0:00:09.177
</code></pre>

<p>To retrieve the friends 1001 calls are made made. Postgres is significantly slower in this case.</p>

<h4 id="Postgres,Create1000000PersonsandDogswithapetedge.BatchModeon.ID">Postgres, Create 1 000 000 Persons and Dogs with a pet edge. BatchMode on.</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testPostgresBatchMode() {
    this.sqlgGraph.tx().batchModeOn();
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 1; i &lt; 1000001; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex dog = this.sqlgGraph.addVertex(T.label, "Dog", "name", "snowy" + i);
        person.addEdge("pet", dog);
        if (1 % 100000 == 0) {
            this.sqlgGraph.tx().commit();
            this.sqlgGraph.tx().batchModeOn();
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();

    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").count().next().intValue());
    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Dog").count().next().intValue());

    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>Postgres</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:00:51.681
Time to read all vertices: 0:00:16.130
</code></pre>

<h4 id="HSQLDB,Create1000000PersonsandDogswithapetedge.ID">HSQLDB, Create 1 000 000 Persons and Dogs with a pet edge.</h4>

<pre class="prettyprint"><code class="language-java">@Test
public void testHsqldbLargeLoad() {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start();
    for (int i = 1; i &lt; 1000001; i++) {
        Vertex person = this.sqlgGraph.addVertex(T.label, "Person", "name", "John" + i);
        Vertex dog = this.sqlgGraph.addVertex(T.label, "Dog", "name", "snowy" + i);
        person.addEdge("pet", dog);
        if (i % 100000 == 0) {
            this.sqlgGraph.tx().commit();
        }
    }
    this.sqlgGraph.tx().commit();
    stopWatch.stop();
    System.out.println("Time to insert: " + stopWatch.toString());
    stopWatch.reset();
    stopWatch.start();

    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Person").count().next().intValue());
    Assert.assertEquals(1000000, this.sqlgGraph.V().&lt;Vertex&gt;has(T.label, "Dog").count().next().intValue());

    stopWatch.stop();
    System.out.println("Time to read all vertices: " + stopWatch.toString());
}
</code></pre>

<p><strong>HSQLDB</strong></p>

<pre class="prettyprint"><code class="language-java">Time to insert: 0:02:32.435
Time to read all vertices: 0:00:19.026
</code></pre>


        </div>
    </div>
    <hr>
    <footer class="pull-right">
        <p>100% open source. Licensed under the Apache Software License 2.0</p>
    </footer>

</div>

<!-- Bootstrap core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="bootstrap/js/bootstrap.min.js"></script>
<script src="javascripts/offcanvas.js"></script>
<script src="javascripts/prettify.js"></script>

<script type='text/javascript'>

    $(document).ready(function () {

        $('#sidebar').affix(
                {
                    offset: {
                        top: 40
                    }
                }
        );

        var $body = $(document.body);
        var navHeight = $('.navbar').outerHeight(true) + 10;

        $body.scrollspy({
            target: '#leftcol',
            offset: navHeight
        });

        /* smooth scrolling sections */
        $('a[href*=#]:not([href=#])').click(function () {
            if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
                var target = $(this.hash);
                target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
                if (target.length) {
                    $('html,body').animate({
                        scrollTop: target.offset().top - 50
                    }, 1000);
                    return false;
                }
            }
        });

    });

    prettyPrint();

</script>

</body>
</html>
